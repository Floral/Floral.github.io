<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《有限与无限的游戏》</title>
    <url>/2024/11/13/%E3%80%8A%E6%9C%89%E9%99%90%E4%B8%8E%E6%97%A0%E9%99%90%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B/</url>
    <content><![CDATA[<p>本blog仅用于记录、摘抄个人在阅读本书时的一些想法和觉得好的语句，比较流水账hhhh</p>
<a id="more"></a>
<h1 id="第一章-世上至少有两种有游戏"><a href="#第一章-世上至少有两种有游戏" class="headerlink" title="第一章 世上至少有两种有游戏"></a>第一章 世上至少有两种有游戏</h1><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>有限游戏的所有限制都是自我限制</p>
<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p>所有有限的游戏中，或多或少存在自我遮蔽。参与者必须有意忘却自己参与游戏所固有的自愿性质，否则，所有竞争、努力都将离他们而去。</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>无限游戏参与者会避开任何结果，对未来保持开放，令所有剧本作废，我们应该称无限游戏为传奇性的。</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>所有真正的有限游戏的剧本都是在游戏进行过程中写就的。</p>
<p>这表示，在游戏进行期间，所有有限游戏都是传奇式的，因为结局位置。未知的结局成就了真正的游戏，而有限游戏的剧本本质与存在结局有关。</p>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>有限的游戏中，惊奇是一个关键元素。</p>
<h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>这里存在一个矛盾：如果赢得有限游戏的奖励是生命，那么参与者便没有好好地活着。他们在争夺生命,生命也就不是赛局,而是赛局的结果。有限游戏参与者参赛是为了活命,他们没有享受自己的参赛。因此,生命是应得的、赋予的、被占有的、赢得的,而不是生活的。“生活本身似乎只是生命的一种手段。”（马克思）</p>
<h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><blockquote>
<p>有点难懂</p>
<p>什么叫死亡是抽象的而非具体的？</p>
</blockquote>
<h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>有限游戏参与者为永生而战，而无限游戏参与者以凡人之躯游戏。</p>
<p>尽管无限游戏参与者选择死亡之躯,但他们可能不知道死亡何时降临,但我们总能说“他们死在合适的时候”。(尼采)</p>
<p>有限游戏的生存之争是严肃的，无限游戏的生存之争是玩乐性质的。</p>
<h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p>无限游戏本身就具有悖论性，正如有限游戏本身就是矛盾的。因为无限游戏参与者的目的是继续赛局,而不是为了自己游戏。有限游戏的矛盾在于,参与者渴望为了自己终结游戏。无限游戏的悖论则是,参与者渴望他人继续。矛盾正是只有他人继续游戏他们才能继续。</p>
<h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>当一个人被他人以头衔相称,人们的注意力便放在了已经结束的过去,关注的是一个已经终结的游戏,并且这个游戏不会再重演。头衔实际上将参与者带离了游戏。</p>
<p>如果一个人只因名字为人所知，他人的关注点则落在开放的未来。我们无法知道该期盼什么。我们以姓名称呼彼此时,忽略了所有的剧本,并开放了所有能让彼此的关系变得深深互惠的可能性。我现在无法预测你的未来,它令我的未来也变得不可预测。我们的未来交织在一起,你的未来和我的未来成为了我们的未来,我们让彼此为惊奇做好准备。</p>
<p>头衔是抽象的，名字总是具体的。</p>
<h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><p>如果我接受死亡是不可避免的，我就不会对抗死亡。我必以死之躯来抗争。</p>
<p>有限游戏的所有限制都是自我限制。</p>
<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>权力只是有限游戏的特征。它不是传奇性(dramatic)的,而是剧本性(theatrical）的。那么无限游戏参与者如何与权力抗衡？无限游戏总是具有传奇性,其结果无休止地开放。不可能回溯过去,对权力和以前游戏的缺陷进行明确的评估。<strong>无限游戏参与者放眼未来,并不着眼于胜利,而是着眼于继续比赛,过去将需要被不断地重新解读。</strong>无限游戏参与者并不对抗他人的行动,而是发起自己的行动,使得他人能够发起自己的行动进行回应。</p>
<p>权力总是被限制在相对较少的被选定的人中,而任何人都能有力量。</p>
<h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>邪恶不是尝试根据已设立和接受的规则来消除他人的竞争,而是不管规则只为消除他人的竞争。邪恶不是对权力的获取,而是权力的表达。它是头衔的被迫认可，这其中潜藏着邪恶的矛盾，因为认可不能被强迫。</p>
<h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><p>邪恶从未想成为邪恶。事实上，所有邪恶中所固有的矛盾是,它滋生于消除邪恶的欲望。“只有死的印第安人才是好人。”</p>
<p>你的历史并不属于我,我们彼此生活在共同的历史中。</p>
<p>无限游戏参与者明白邪恶之不可避免，因此，他们并不试图消除他人的邪恶,因为这种做法正是邪恶本身的冲动。他们只是试图矛盾地认识到自己内心的邪恶,这种邪恶以试图消除别处邪恶的形式存在。</p>
<blockquote>
<p>不干涉他人？</p>
</blockquote>
<h1 id="第二章-没人能独自玩游戏"><a href="#第二章-没人能独自玩游戏" class="headerlink" title="第二章 没人能独自玩游戏"></a>第二章 没人能独自玩游戏</h1><h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><p>没有人能独自一人玩游戏。一个人不成其为人，没有群体，便没有自我。我们并不是作为我们本身与他人有关系,相反,我们是与他人有关系的我们。</p>
<p>和禅宗的观念一样,我们并不是僵硬的石头,世界之水流在它上面缓缓而过,我们其实是水流自身。我们会看到,这一永不停息的变化并不意味着持续性的断裂,相反,变化是我们人之为人的持续性的一个基础。只有能够变化的,才能够持续下去,这是无限游戏的参与者所遵循的原则。</p>
<h2 id="33"><a href="#33" class="headerlink" title="33"></a>33</h2><p>“我们必须学会战争和独立的艺术,只有这样,我们的孩子才能学会建筑和工程的艺术,然后他们的孩子才能学到美术等高雅艺术。”(约翰·昆西·亚当斯)</p>
<p>在无限游戏模式下,作为政治人，绝非无视许多人类同胞所生活的恶劣条件，消除这些恶劣条件是政治的题中应有之义。我们可以想象，无限游戏的参与者面对卢梭的名言“人生而自由，但无往而不在枷锁中”时，会若有所思地点点头。他们明白，对自由的梦想是无处不在的：为了赢得自由，人们发动战争；为了保卫自由，英雄们付出生命；为了赞美自由的实现，一首又一首颂歌被谱写出来。</p>
<p>因此,对无限游戏的参与者而言,政治是一种舞台剧。它是根据某一剧本,面向观众的角色表演,而表演者预先便已知晓了剧本的最后一幕。比如,美国在东南亚的失利,与其说输掉了战争,不如说失掉了战争的观众。毫无疑问,战士们的幻灭与苦楚,不少是由于缺少最后一幕——迎接英雄凯旋的游行队伍或者送葬仪式,而这一预想中的场景曾鼓舞战士们不惜抛头颅洒热血。</p>
<blockquote>
<p>为什么说是剧本？因为最后一幕一般是可以预测的。</p>
</blockquote>
<p>无限游戏的参与者在他们自己的政治活动中，严格区分社会与文化。他们将社会理解为受政治约束的关系总和,而文化则是在非方向性的选择下，人和人的相互作用。如果说,社会是人们认为必须要做之事的总和，那么文化则是“变化与自由的国度，它并不一定普遍适用,权威在这里无从置喙”。(布克哈特2)</p>
<p>因此，社会与文化并不是真正的势不两立。其实，社会是文化的一种类型,它坚持与自身作对。社会是自由组织起来的一种努力，致力于隐藏组织者和被组织者的自由，<code>致力于忘记我们已经有意识地忘记我们进入这个或那个竞赛的初衷并继续竞赛下去。</code></p>
<h2 id="34"><a href="#34" class="headerlink" title="34"></a>34</h2><p>如果将社会理解为人们在必然的面纱下所做的一切，那也应该将它视为某一有限的游戏,在它的边界内,又包含了一定数量的小游戏。大的社会包括大量的各种游戏,虽然这些游戏都在某种程度上联系在一起,因为它们都影响到最终的社会身份地位。学校向获得学位者颁发含金量各不同的学位证书,从这个意义上说,学校是有限游戏的一种。</p>
<p>一个社会只有在与其他社会关系中保持整体性的权力时,其社会成员所赢得的奖励才能得到保卫。希望将自己的奖励永久化的社会成员,会努力维持这个社会奖励的永久化。爱国主义以它的一种或多种形式(沙文主义、种族主义、性别主义、民族主义和宗教主义),成为所有社会游戏不可分割的部分。</p>
<h2 id="35"><a href="#35" class="headerlink" title="35"></a>35</h2><p>文化则是无限的游戏。文化无边界,在一个文化中,所有人都能成为参与者,无论任何时间任何地点。</p>
<hr>
<p>社会是权力的展示。它是剧本性的,拥有既定的剧本,对剧本的偏离,马上会很明显地被看出来。偏离常轨是反社会的,因此被社会通过各种制裁所禁止。越轨之所以被禁止,原因很简单。如果社会成员不遵守社会固有规则,那么规则的数量将会变化，其中一些规则会被彻底抛弃,这将意味着过去的获胜者不再能保证获得对自己头衔的仪式性认可,从而失去权力—就像是俄国革命之后的俄国王公。</p>
<hr>
<p>然而,越轨却是文化的本质。谁要是仅仅跟随剧本亦步亦趋,重复过去,那么就是文化上的赤贫者。</p>
<p>越轨的性质各有不同,不是所有对过去的偏离都具有文化上的意义。切断与过去的联系,导致对过去的遗忘,这些做法在文化上毫无价值。给传统带来新的思维方式,使我们对一度熟悉的事物生出陌生感,对我们所拥有的一切进行再审视,这样做才是有意义的。</p>
<h2 id="36"><a href="#36" class="headerlink" title="36"></a>36</h2><p>有限游戏的获胜者赢得的是头衔。头衔是其他人对于特定游戏中获胜者的一种承认,自己不能自封头衔。头衔是剧本性的,要求得到观众的授予和尊敬。</p>
<p>财产的目的,就是使我们的头衔变得可见,财产是标志性的。它让其他人想起我们所向披靡的那些获胜领域。</p>
<p>财产也许会被偷,但是小偷并不因此占有它。物主身份是永远偷不走的。头衔是无时间性的，财产亦然。</p>
<h2 id="37"><a href="#37" class="headerlink" title="37"></a>37</h2><p>强制力是由一致意见建立的。只有同意社会各种条条框框的人，才会将它们视为条条框框──也就是说，将它们看做行动的指南，而非可被反对的行动。</p>
<h2 id="38"><a href="#38" class="headerlink" title="38"></a>38</h2><p>财产应该被视为一种补偿。</p>
<p>财产应该被视为是被消费的。</p>
<h2 id="39"><a href="#39" class="headerlink" title="39"></a>39</h2><p>只要财产所有人能够显示他所得到的只不过相当于为了得到它而付出的艰辛，财产便恰如其分地是补偿性的。财产所有人的付出，和他通过头衔从别人那里得到的收获，二者之间必须是对等的。若人们无法显示他们的既有财富和要获得此财富应冒风险之间有对等关系时，他们的头衔便会遭到质疑。富有者经常成为小偷、赋税的目标，老百姓也希望能分享其财富，就好像他们的财富并不只是补偿，因此并不完全属于他<br>们。</p>
<hr>
<p>财产必须占有空间。它必须位于某个醒目的地方。也就是说，它必须以一种他人能碰到并且注意到的形式存在。我们的财产必然会打扰他人，挡住他人的道，导致他人起争夺之心。</p>
<hr>
<p>对于财产所有人来说，其中潜藏的危机并不在于财产的数额，而在于财产拥有吸引观众注意力的能力，因为对这些观众而言，财产应是恰到好处地标志性的。也就是说，这些观众将财产等同于在获取财产的过程中所付出的努力和技能的补偿。</p>
<h2 id="40"><a href="#40" class="headerlink" title="40"></a>40</h2><p>财产所有者身上还背负着第二重剧本性要求的包袱。一旦他们使人们留意到在获得他们所拥有财产时付出了多少，他们就必须消费自己因付出而所获得的。这里的直觉式原则是，拥有自己不需要使用或者未计划使用之物，是没有道理的。人们赚钱并不是仅仅为了把钱存起来，以避免未来有任何使用它的可能性。</p>
<p>消费这样一种活动，直接对立于赢得头衔的竞争行为。消费必须是这样一种活动，即能够让旁观者确信，财产拥有者的身份不再受到质疑。</p>
<p>消费这种活动与辛苦的劳动是如此不同，它以休闲，甚至懒惰为表现方式。我们通过无所事事，来展现过去辛劳所换来的成功。因而，我们越是多多消费，我们就越能将自己的过去竞争的获胜者身份显示出来。“在劳动中缺席因此成为非凡金钱成就和名誉的惯用标志，相反，由于从事生产性劳动是贫穷与服从的标记，所以它便与社会中的受尊敬身份全然无关。”（凡勃伦㊟ ）</p>
<p>正如补偿通过占据空间而使自身变得醒目，消费是通过它所占据的时间来吸引注意力。财产不仅必须打扰到他人，而且必须持续地打扰他人。</p>
<p>很显然，对无限游戏的参与者来说，当财富与其说是被拥有的，不如说是被消费的。</p>
<h2 id="41"><a href="#41" class="headerlink" title="41"></a>41</h2><p>一些社会相信，要是能保证包括窃贼在内的所有社会成员都有一份体面的财产──许多社会福利立法便是基于此想法──盗窃就能被根除。但是将一枚硬币放到机灵鬼的口袋里，是不可能说服他为了一枚硬币，放弃整座金矿。</p>
<p>对一个社会而言，更有效的防盗策略是让窃贼们放弃财产竞争者的身份，转而成为财富剧本的观众。也正<br>是出于这个原因，社会有赖于那些创造者的技能──他们能够将财产关系甚至每一社会的内在结构都剧本<br>化。</p>
<blockquote>
<p>这里有待思考</p>
</blockquote>
<p>所有知晓这一剧本化的社会理论家都应该受到最严肃的对待。没有剧本化，也便没有文化。一个没有文化<br>的社会将如一团死水，令人无法忍受。</p>
<p>即便在柏拉图的理想国中，在它专制的硬壳下，还是有“许多不必要的人和物──例如各种猎人、模仿形象与色彩的艺术家，一大群搞音乐的，诗人和一大群助手──朗诵者、演员、合唱队、舞蹈队、管理员以及制造各种家具和用品的人，特别是做妇女装饰品的那些人”（柏拉图）。</p>
<p>如果财富和力量应被表演，那么巨大的财富和力量就应该被天才式地表演。</p>
<h2 id="42"><a href="#42" class="headerlink" title="42"></a>42</h2><p>因此，每一个社会最深刻最主要的斗争并不是与其他社会的斗争，而是与存在于它内部的文化的斗争──文化即是它本身。与其他社会的冲突，实际上是一个社会限制其自身文化极有效的手段。大权在握的社会并不是为了投入战争而让它们的创造者闭嘴，相反，投入战争正是让创造者沉默的一种手段。原创的思想家可能被处决或流放而遭到镇压，或者他们会因为贪求荣华富贵或者拍马溜须，转而去赞美社会的英雄。</p>
<p>社会对抗其内部文化的另一个成功方法，是给予艺术家们一块地方，将他们视为财产的生产者，于是便提<br>高了消费艺术的价值，或者拥有它。很明显，那些大型的艺术收藏，所有世界级的博物馆，都来自民族主<br>义高涨时期巨富或者政府的所为。</p>
<p>这些博物馆的创立初衷并不是保护艺术品免于遭受人民破坏，而是使人民免于接触艺术。</p>
<blockquote>
<p>这一小节也有点烧脑</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《有限与无限的游戏》</category>
      </categories>
      <tags>
        <tag>人生哲学</tag>
        <tag>人生是一场游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python 3.12 安装D2L包时报错：module &#39;pkgutil&#39; has no attribute &#39;ImpImporter&#39;</title>
    <url>/2024/10/26/python-3-12-%E5%AE%89%E8%A3%85D2L%E5%8C%85%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Amodule-pkgutil-has-no-attribute-ImpImporter/</url>
    <content><![CDATA[<p>前情提要：</p>
<p>工作后，原本对AI不屑一顾的我，终究还是捡起了AI（つ﹏⊂），真香.jpg（</p>
<p>然后找了找教程，发现<a href="https://zh-v2.d2l.ai/#" target="_blank" rel="noopener">《动手深度学习》</a>这个教程非常好，于是，<a href="https://docs.anaconda.com/miniconda/" target="_blank" rel="noopener">miniconda</a>，下载！python，启动！Jupyter、D2L，安装！</p>
<p>由于miniconda下载的是最新版，所以python默认是3.12.7版本，然后在安装D2L包的时候遇到了如下报错。。。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxxxxxxxx（一堆看不懂的东西）</span><br><span class="line"></span><br><span class="line">AttributeError: module <span class="string">'pkgutil'</span> has no attribute <span class="string">'ImpImporter'</span>. Did youean: <span class="string">'zipimporter'</span>?</span><br></pre></td></tr></table></figure>
<p>遇上上网一顿搜，发现可能是D2L包中指定<code>numpy</code>的版本与python312不匹配的问题，需要我们自行下载源码然后修改numpy的版本。</p>
<p>后续操作：</p>
<ol>
<li>到<a href="https://repo.huaweicloud.com/repository/pypi/simple/d2l/" target="_blank" rel="noopener">华为的镜像仓库</a>下载D2L的源码（我下的是<code>1.0.3</code>版本</li>
</ol>
<p>解压，然后进入到解压后的文件夹目录，如下，</p>
<p><img src="/2024/10/26/python-3-12-%E5%AE%89%E8%A3%85D2L%E5%8C%85%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Amodule-pkgutil-has-no-attribute-ImpImporter/image-20241026223341774.png" alt="解压后的源码文件夹内容" style="zoom:50%;"></p>
<ol>
<li>修改<code>setup.py</code>方法中的requirements为如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requirements = [</span><br><span class="line">    <span class="string">'jupyter==1.0.0'</span>,</span><br><span class="line">    <span class="string">'numpy==1.26.3'</span>,	<span class="comment"># 主要是这里的版本</span></span><br><span class="line">    <span class="string">'matplotlib==3.8.2'</span>,</span><br><span class="line">    <span class="string">'matplotlib-inline==0.1.6'</span>,</span><br><span class="line">    <span class="string">'requests==2.31.0'</span>,</span><br><span class="line">    <span class="string">'pandas==2.2.0'</span>,</span><br><span class="line">    <span class="string">'scipy==1.12.0'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li>执行：<code>python setup.py install</code></li>
</ol>
<p>顺利的话这一步应该就能够解决，但我不顺利/(ㄒoㄒ)/~~</p>
<p>你可能会卡在从pypi库中下载scipy包（或者其他包），这里感觉是源的问题，然后上网搜索pip修改源的方法，永久修改为清华源，仍然会卡在这，而且看命令行的信息，下载的源并没有修改，很迷。。。ctrl+c后，再次运行会产生一个<code>xxx.egg</code>文件被使用无法删除的错误，手动找到这个文件删除即可。</p>
<ol>
<li>最终解决</li>
</ol>
<p>最后使用<code>pip</code>指令来安装刚刚下载的D2L源码，安装的指令需要指定源，需要在上面图片的那级目录下执行，具体指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install . --index-url https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>
<p>install后面的<code>.</code>，表示是当前目录（即需要被安装的源码目录），使用<code>--index-url</code>参数指定源，<code>--trusted-host</code>参数表示信任后面的主机（对于SSL证书有问题的来说，这里不加应该也行）。</p>
]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>打工人的日常</category>
      </categories>
      <tags>
        <tag>动手深度学习</tag>
        <tag>python</tag>
        <tag>D2L</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU ICS2023 PA开发日记</title>
    <url>/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><strong>2024/08/22</strong></p>
<p>从今天开始，正式准备启动这个“项目”啦！（其实已经看过一段时间前面的基础介绍了</p>
<p>希望能够坚持做完！！！(ง •_•)ง</p>
<p>这里主要记录一下做PA过程中遇到的问题和思考（以及内心戏</p>
<blockquote>
<p>不过后面一个月要去外地培训了。。。还不知道弄</p>
</blockquote>
<a id="more"></a>
<h1 id="1-PA1"><a href="#1-PA1" class="headerlink" title="1. PA1"></a>1. PA1</h1><h2 id="1-3-RTFSC"><a href="#1-3-RTFSC" class="headerlink" title="1.3 RTFSC"></a>1.3 RTFSC</h2><p><code>getopt_long()</code>函数的作用？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       int getopt(int argc, char * const argv[],</span><br><span class="line">                  const char *optstring);</span><br><span class="line"></span><br><span class="line">       extern char *optarg;</span><br><span class="line">       extern int optind, opterr, optopt;</span><br><span class="line"></span><br><span class="line">       #include &lt;getopt.h&gt;</span><br><span class="line"></span><br><span class="line">       int getopt_long(int argc, char * const argv[],</span><br><span class="line">                  const char *optstring,</span><br><span class="line">                  const struct option *longopts, int *longindex);</span><br><span class="line"></span><br><span class="line">       int getopt_long_only(int argc, char * const argv[],</span><br><span class="line">                  const char *optstring,</span><br><span class="line">                  const struct option *longopts, int *longindex);</span><br><span class="line">                  </span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  getopt()  function  parses  the command-line arguments.  Its arguments argc and argv are the argument count and array as passed to the main() function on program invocation.  An element of argv that starts</span><br><span class="line">       with &#39;-&#39; (and is not exactly &quot;-&quot; or &quot;--&quot;) is an option element.  The characters of this element (aside from the initial &#39;-&#39;) are option characters.  If getopt() is called  repeatedly,  it  returns  successively</span><br><span class="line">       each of the option characters from each of the option elements.</span><br><span class="line"></span><br><span class="line">       The  variable optind is the index of the next element to be processed in argv.  The system initializes this value to 1.  The caller can reset it to 1 to restart scanning of the same argv, or when scanning a new argument vector.</span><br><span class="line"></span><br><span class="line">       If getopt() finds another option character, it returns that character, updating the external variable optind and a static variable nextchar so that the next call to getopt() can resume the scan with the following option character or argv-element.</span><br><span class="line"></span><br><span class="line">       If there are no more option characters, getopt() returns -1.  Then optind is the index in argv of the first argv-element that is not an option.</span><br><span class="line">       optstring is a string containing the legitimate option characters.  If such a character is followed by a colon, the option requires an argument, so getopt() places a pointer to the following text in the same argv-element, or the text of the following argy-element, in optarg.  Two colons mean an option takes an optional arg;  if there is text in the current argv-element (i.e., in the same word as the option name itself, for example, &quot;-oarg&quot;), then it is returned in optarg, othenwise optarg is set to zero.  This is a GNU extension.  If optstring contains W followed by a senicolon, then -W foo is treated as the long option --foo.  (The -W option is reserved by POSIX.2 for implementation extensions.)  This behavior is a GNU extension, not available with libraries before glibc 2. </span><br><span class="line">       By default, getopt() permutes the contents of argy as it scans, so that eventually all the nonoptions are at the end.  Two other modes are also implemented.  If the first character of optstring is &#39;+&#39; or the environment variable POSIXLY_CORRECT is set, then option processing stops as soon as a nonoption argument is encountered.  If the first character of optstring is &#39;-&#39;, then each nonoption argv-element is handled as if it were the argument of an option with character code 1.  (This is used by prograns that were written to expect options and other argy-elenents in any order and that care about the ordering of the two.)  The special argument &quot;--&quot; forces an end of option-scanning regardless of the scanning mode.l</span><br></pre></td></tr></table></figure>
<p>got，用来解析命令行参数的。</p>
<h3 id="1-3-1-准备第一个客户程序"><a href="#1-3-1-准备第一个客户程序" class="headerlink" title="1.3.1 准备第一个客户程序"></a>1.3.1 准备第一个客户程序</h3><blockquote>
<p><strong>为什么全部都是函数?</strong></p>
<p>阅读<code>init_monitor()</code>函数的代码, 你会发现里面全部都是函数调用. 按道理, 把相应的函数体在<code>init_monitor()</code>中展开也不影响代码的正确性. 相比之下, 在这里使用函数有什么好处呢?</p>
<p>这样有利于抽象内部设计，使得设计更加层次分明</p>
<p><strong>2024/08/23</strong></p>
</blockquote>
<p>NEMU是一个用来执行客户程序的程序（模拟计算机），但是NEMU一开始并没有客户程序（OS或其他客户程序），需要有程序将客户程序读入计算机中，NEMU项目src中的monitor就是用来干这个事的（也包含调试的功能<code>sdb</code>）。</p>
<p>monitor中调用<code>init_isa()</code>来进行ISA的一些初始化：</p>
<ol>
<li>将一个内置客户程序读入内存中</li>
<li>初始化虚拟计算机系统（初始化寄存器，<code>restart()</code>函数）</li>
</ol>
<p>读入客户程序到内存中，读到什么位置？NEMU采用最简单的方式——约定一个位置，可由我们配置，定义在<code>nemu/include/memory/paddr.h</code>中，定义为RESET_VECTOR。</p>
<p>NEMU默认提供128MB的内存，模拟内存定义在<code>src/memory/paddr.c</code>中，定义为<code>pmem</code></p>
<blockquote>
<p>RISC-V32（以及MIPS32）的默认物理内存地址是从<code>0x80000000</code>开始编址的， 将来CPU访问内存时, 会将CPU将要访问的内存地址映射到<code>pmem</code>中的相应偏移位置，这是通过<code>nemu/src/memory/paddr.c</code>中的<code>guest_to_host()</code>函数实现的。</p>
</blockquote>
<p><strong>可能这个RESET_VECTOR就相当于真实计算机启动的第一个地址？存放BIOS的位置？</strong></p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20240823232125339.png" alt="Welcome to riscv32-NEMU!" style="zoom: 80%;"></p>
<p>成功运行！！！</p>
<blockquote>
<p><strong>2024.10.26记</strong></p>
<p>果然。。。中途荒废了一个月再捡起来就需要勇气了hhh，</p>
<p>荒废了两个月后，我终于又准备回来了！</p>
<p><strong>2024.12.15记</strong></p>
<p>真的回来了（</p>
<p><strong>2024/12/15</strong></p>
</blockquote>
<p>NEMU最开始默认的客户程序定义在init.c函数中，如下：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241215223855685.png" alt="image-20241215223855685"></p>
<p>其中的img就是4条指令+一个数据。也可以在运行NEMU的时候添加一个参数，指定外部的镜像文件加载。</p>
<h3 id="1-3-2-运行第一个客户程序"><a href="#1-3-2-运行第一个客户程序" class="headerlink" title="1.3.2 运行第一个客户程序"></a>1.3.2 运行第一个客户程序</h3><blockquote>
<h5 id="究竟要执行多久"><a href="#究竟要执行多久" class="headerlink" title="究竟要执行多久?"></a>究竟要执行多久?</h5><p>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?</p>
<p><strong>A：</strong>将-1转换成uint64_t的最大值，即执行0xFFFFFFFFFFFFFFFF这么多条指令（如不是指令自行退出的话）</p>
<h5 id="潜在的威胁-建议二周目思考"><a href="#潜在的威胁-建议二周目思考" class="headerlink" title="潜在的威胁 (建议二周目思考)"></a>潜在的威胁 (建议二周目思考)</h5><p>“调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>“, 这一做法属于未定义行为吗? 请查阅C99手册确认你的想法。</p>
<p><strong>A：</strong>好的，那就二周目再思考（</p>
</blockquote>
<p>进入<code>sdb_mainloop()</code>函数后，会通过<code>cmd_table</code>结构体中的<strong>函数指针</strong>（<code>handler</code>）来调用不同的函数，输入<code>c</code>就可以运行内置的img。但是再次输入<code>c</code>的话会提示需要重新运行NEMU才能。。。</p>
<p><code>sdb_mainloop()</code>函数中的<code>strtok()</code>函数是用来分割字符串的，类似python的split函数，可以指定分割标志。</p>
<p>有意思的是其中的<code>nemu_trap</code>指令，它是为了在NEMU中让客户程序指示执行的结束而加入的, NEMU在ISA手册中选择了一些用于调试的指令, 并将<code>nemu_trap</code>的特殊含义赋予它们。例如在riscv32的手册中, NEMU选择了<code>ebreak</code>指令来充当<code>nemu_trap</code>. 为了表示客户程序是否成功结束, <code>nemu_trap</code>指令还会接收一个表示结束状态的参数。</p>
<p><strong>RTFM：</strong></p>
<p>RISC-V的基础指令格式有如下4种：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241217232430933.png" alt="image-20241217232430933"></p>
<p>RISC-V种，<code>EBREAK</code>指令可以用<code>SYSTEM</code>指令实现，如下：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241218224222172.png" alt="image-20241218224222172"></p>
<p><code>ECALL</code>和<code>EBREAK</code>的功能都是在<code>SYSTEM</code>这个opcode下实现的，<code>ECALL</code>的<code>funct12</code>是0，<code>EBREAK</code>的<code>funct12</code>是1。</p>
<p>其中，<code>EBREAK</code>是用于将控制权返回给调试环境。</p>
<p>NEMU中，<code>EBREAK</code>指令的实现是将<code>nemu_state.state</code>置为NEMU_END，将<code>nemu_state.halt_pc</code>置为当前PC，将<code>nemu_state.halt_ret</code>置为10。</p>
<blockquote>
<p>Note：</p>
<p>什么是trap？</p>
<p>问了一下GPT：</p>
<p><strong>Trap</strong> 是指在程序执行过程中，处理器遇到某些事件时，将控制权从当前程序转移到操作系统或异常处理程序的一种机制。<br>它可以由程序主动触发（如系统调用），也可以由硬件自动触发（如异常或中断）。</p>
<p>STFW：<a href="https://zhuanlan.zhihu.com/p/460874372" target="_blank" rel="noopener">操作系统小结（三）- Trap机制 - 知乎</a></p>
<p>so，基本上就是用来切换执行的代码流的（个人理解）。</p>
<h5 id="谁来指示程序的结束"><a href="#谁来指示程序的结束" class="headerlink" title="谁来指示程序的结束?"></a>谁来指示程序的结束?</h5><p>在程序设计课上老师告诉你, 当程序执行到<code>main()</code>函数返回处的时候, 程序就退出了, 你对此深信不疑. 但你是否怀疑过, 凭什么程序执行到<code>main()</code>函数的返回处就结束了? 如果有人告诉你, 程序设计课上老师的说法是错的, 你有办法来证明/反驳吗? 如果你对此感兴趣, 请在互联网上搜索相关内容。</p>
<p><strong>STFW：</strong>在程序终止前，可能会存在一些清理操作，例如关闭打开的文件、释放分配的内存等。这些清理操作可以在主函数的最后部分执行，调用<code>atexit()</code>函数即可。</p>
<h5 id="有始有终-建议二周目思考"><a href="#有始有终-建议二周目思考" class="headerlink" title="有始有终 (建议二周目思考)"></a>有始有终 (建议二周目思考)</h5><p>对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束? 对于在NEMU中运行的程序, 问题的答案又是什么呢?</p>
<p>与此相关的问题还有: NEMU中为什么要有<code>nemu_trap</code>? 为什么要有monitor?</p>
<p>对于下面的问题，<strong>一周目的回答：</strong>为了暂停/终止当前程序的执行，将CPU的控制权交给其他程序（OS/monitor），monitor是用来调试的（吧。。</p>
</blockquote>
<p>代码中有一些值得注意（学习），直接摘抄过来：</p>
<blockquote>
<p>三个对调试有用的宏(在<code>nemu/include/debug.h</code>中定义)</p>
<ul>
<li><code>Log()</code>是<code>printf()</code>的升级版, 专门用来输出调试信息, 同时还会输出使用<code>Log()</code>所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置</li>
<li><code>Assert()</code>是<code>assert()</code>的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息</li>
<li><code>panic()</code>用于输出信息并结束程序, 相当于无条件的assertion fail</li>
</ul>
<p>内存通过在<code>nemu/src/memory/paddr.c</code>中定义的大数组<code>pmem</code>来模拟. 在客户程序运行的过程中, 总是使用<code>vaddr_read()</code>和<code>vaddr_write()</code> (在<code>nemu/src/memory/vaddr.c</code>中定义)来访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址. </p>
<h5 id="优美地退出"><a href="#优美地退出" class="headerlink" title="优美地退出"></a>优美地退出</h5><p>为了测试大家是否已经理解框架代码, 我们给大家设置一个练习: 如果在运行NEMU之后直接键入<code>q</code>退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p>
</blockquote>
<p>终于有一个练习了！</p>
<p>在NEMU中直接输入<code>q</code>和输入<code>c</code>之后再输入<code>q</code>的结果确实不一样！如下：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241224234747535.png" alt="image-20241224234747535"></p>
<p>输入<code>c</code>之后再输入<code>q</code>能够优雅地退出，并没有报错，而直接输入则会报错。通过<code>echo $?</code>查看程序的返回值，发现直接退出的返回值是2，而正常的是0，所以问题出在返回值上。</p>
<p>PS：在menu里开启debug配置后，输入<code>make gdb</code>，可以调试NEMU</p>
<p>一个疑惑是，进入gdb调试后，发现直接退出返回的值是1，并不是2！这是为什么呢？值得思考，怀疑是make程序进行了再次返回，于是直接在命令行运行NEMU而不是通过make命令，得到以下结果：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241225002014939.png" alt="image-20241225002014939" style="zoom:50%;"></p>
<p>猜想正确。（还可以深究一下为什么make会在返回值1的基础上返回2？</p>
<p>不过，程序会报错的原因找到了，就是因为返回值不为0，而控制返回值的函数在<code>/src/utils/state.c</code>中的函数<code>is_exit_status_bad()</code>：</p>
<p><img src="/2024/08/22/NJU-ICS2023-PA%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20241225002317465.png" alt="image-20241225002317465"></p>
<p>说明退出时不满足这个条件，返回去看<code>sdb_mainloop()</code>函数中的调用逻辑，运行<code>c</code>命令的话，会执行img程序，会使得<code>nemu_state</code>满足good表达式中的前一个条件，而直接输入<code>q</code>则直接返回-1，不会修改<code>nemu_state</code>的状态，于是不满足good的条件，所以为0，返回1，于是修改调用的<code>cmd_q()</code>函数，设置<code>nemu_state</code>的状态为<code>NEMU_QUIT</code>，即可实现“优雅地退出”。</p>
<blockquote>
<p>事实上, TRM的实现已经都蕴含在上述的介绍中了.</p>
<ul>
<li>存储器是个在<code>nemu/src/memory/paddr.c</code>中定义的大数组</li>
<li>PC和通用寄存器都在<code>nemu/src/isa/$ISA/include/isa-def.h</code>中的结构体中定义</li>
<li>加法器在… 嗯, 这部分框架代码有点复杂, 不过它并不影响我们对TRM的理解, 我们还是在PA2里面再介绍它吧</li>
<li>TRM的工作方式通过<code>cpu_exec()</code>和<code>exec_once()</code>体现</li>
</ul>
</blockquote>
<h2 id="1-4-基础设施"><a href="#1-4-基础设施" class="headerlink" title="1.4 基础设施"></a>1.4 基础设施</h2>]]></content>
      <categories>
        <category>随笔</category>
        <category>NJU ICS2023 PA</category>
      </categories>
      <tags>
        <tag>NEMU</tag>
        <tag>NJU</tag>
        <tag>ICS2023</tag>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FPGA的MPU6050姿态解算（3）</title>
    <url>/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h2 id="本篇为沉浸式DEBUG记录（"><a href="#本篇为沉浸式DEBUG记录（" class="headerlink" title="本篇为沉浸式DEBUG记录（"></a>本篇为沉浸式DEBUG记录（</h2><p>废话比较多，纯流水账和我自己的内心戏，大家看个乐，最后的总结就是两点：</p>
<ol>
<li>好好写tb，测试数据尽量多</li>
<li>用杜邦线的时候要保证连接的稳定性，因为杜邦线很容易松动，导致传输出错</li>
</ol>
<a id="more"></a>
<h3 id="BUG1："><a href="#BUG1：" class="headerlink" title="BUG1："></a>BUG1：</h3><p>数码管上显示的ROLL角度值目测是正确的，但是经过data_packing之后就传输错误，具体错误是上位机解码错误，通过串口调试器查看接收到的数据之后，发现经过一段时间的传输后，每一帧的数据量并不是13字节，如下：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220315111552606.png" alt="image-20220315111552606" style="zoom:50%;"></p>
<p>从220行开始就错位了。</p>
<ol>
<li>尝试不同UART速率，问题仍存在</li>
<li>UART改为每次间隔一个空闲位传输，问题仍存在</li>
</ol>
<p>同时可以发现，前面正确的每一帧，最后两个checksum计算存在问题，例如可以带入208行的数据验算一下，发现checksum就是错的，这个问题的原因很简单，就是我代码截位因为马虎写错了。</p>
<p>经过ILA的波形抓取分析，发现FIFO在一段时间后一直处于满的状态，这将导致后面的数据写不进去，进而导致丢数据。</p>
<p><strong>根本原因是I2C的读取速率与UART发送的速率不匹配。</strong></p>
<p>下面来分析一下，I2C配置的分频后的时钟是400K，但是根据I2C ip中的verilog，实际的SCL频率要除以2，也就是200K，1s能传输200K bit，一组数据大约是7x16+=128bit，1s能读取3125组数据，一组数据经过处理会变成13字节的一帧，也就是1s产生3125帧。</p>
<p>UART的发送速率假设为115200，那么就是1s发送115200个bit，发送一个字节要1+1+8+1=11bit，1s就只能发送大约10472个字节，再除以一帧13个字节，1s最多只能发送805帧。</p>
<p>产生数据的速度大约是发送数据的4倍，这很不行。所以，我们要限制数据产生的速率（或者方案2就是当FIFO不能保存一帧的时候就丢弃整个帧，不过这要判断FIFO还差多少个数据就满，能不能保存一帧）。</p>
<p>具体方案是，写一个定时器，定时频率是800Hz，每次读取一组。</p>
<p>增加了timer之后，发现FIFO仍然会存满，同时发现，在CALCULATE状态下，再按一下key，理论上应该是WAIT模式，但是角度数据还在更新，于是怀疑是不是I2C的WAIT并不是真的WAIT。</p>
<p>原来是Kalman_Filter的calib_done没有输出连到Kalman_Ctrl上，wtm裂开</p>
<p><strong>连好后，问题仍存在o(≧口≦)o</strong></p>
<p>继续找bug，发现将I2C切换为Wait模式时，前一个连续读取的停止信号没有发送完就进入了等待状态，可能导致I2C从机一直以为没有停止，从而导致后续数据读取错误。</p>
<p>修复这个bug后（如下图），上位机接收的误码率从100%降到了30%左右！！！说明之前的主要问题就是这个！</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220316170826188.png" alt></p>
<h3 id="BUG2："><a href="#BUG2：" class="headerlink" title="BUG2："></a>BUG2：</h3><p>接下来观察传过来的数据：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220316225947129.png" alt="image-20220316225947129" style="zoom:50%;"></p>
<p>发现其中还是有个别数据传输错误，例如把帧开头的AA、FF传成53、F7，不过这次有个好消息，就是没有掉数据或莫名多数据的情况发生（因为FIFO一直没有满）。</p>
<p>同时，debug发现计算出的最优角度值也有问题，例如下图：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220316211540410.png" alt="image-20220316211540410"></p>
<p>此时MPU是平放状态，但是放大一百倍后的数值仍然有-2295，那么原值就是-22.95°，这很离谱。暂时先不管，我们先看UART传输错误的问题。</p>
<p>通过计算一行数据的校验和1（例如截图中的第一行，即29957行），把53、F7当作原来的AA和FF来计算checksum1，发现开头两个字节确实是由于误码造成的：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220316230343166.png" alt="image-20220316230343166"></p>
<p>但是！发现checksum2还是有问题的，发现是少加了一次，但是修改后，上位机接收的checksum2还是有问题！应该也属于误码</p>
<p>分析一下可能的原因：</p>
<ol>
<li><p>波特率产生不稳从而导致误码，因为是通过任意分频器产生的，有误差</p>
</li>
<li><p>波特率过大导致误码率增大</p>
</li>
</ol>
<p>第一次尝试，增加任意分频器的精度（以及增加bps_en对baud_gen进行重置），稍微降低了一点误码率，但还是在25%左右，失败</p>
<p>第二次尝试，降低波特率，首先降低一半，到57600</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220317104153894.png" alt="image-20220317104153894" style="zoom:50%;"></p>
<p><strong>这次可喜的是，checksum1和checksum2传输都完全正确，且最开始的几十组数据都没有出现误码！！！</strong></p>
<p>但是到了后面仍然出现错位（下图），查看一下FIFO的full信号，原来是FIFO又满了呀。</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220317104210898.png" alt="image-20220317104210898" style="zoom:50%;"></p>
<p>重新计算一下需要的mpu timer频率，57600/11≈5236 Bytes，5236/13≈402帧，所以要降低timer的频率到400Hz</p>
<p>误码率很不稳定，有时15%，有时99%。</p>
<p>直接降到9600，9600/11/13=67………wtf？？？？为什么误码率又飙升到100%，麻了</p>
<blockquote>
<p>修复粗心bug：</p>
<ol>
<li><p>读取acc和gyro的数据量是14字节，不是7字节</p>
</li>
<li><p>acc_rdy和gyro_rdy产生的时间早了一个周期</p>
</li>
</ol>
</blockquote>
<p>现在重新分析原因：</p>
<ol>
<li>UART模块传输数据不稳定的原因</li>
<li>UART中FIFO的写入和读出不一致的原因（时序导致的）</li>
</ol>
<h4 id="3-23更新！！！"><a href="#3-23更新！！！" class="headerlink" title="3.23更新！！！"></a>3.23更新！！！</h4><p>死活也没想到，还是因为我的代码写的有问题（つ﹏⊂），但是我之前是有单独验证这个模块的，只不过没有模拟实际的情况来写testbench，今天想着单独测试一下UART模块，为此甚至买了一个逻辑分析仪！然后想着还是<strong>模拟实际传输情况写一个testbench吧</strong>，结果就！发现了问题！</p>
<p>主要问题出在波特率发生器的使能信号上：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span>	bps_clk_en	=	((!fifo_empty_in) &amp; bps_en);	<span class="comment">//这是有bug的版本</span></span><br><span class="line"><span class="keyword">assign</span>	bps_clk_en	=	fifo_empty_in ? (state_current!=STATE_IDLE) : bps_en;	<span class="comment">//这是修改后的版本</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220323214334455.png" alt="image-20220323214334455"></p>
<p>原来的写法导致了在读取FIFO中最后一个数据之后，由于<code>FIFO_EMPTY</code>立马变成了1，导致<code>bps_clk_en</code>变为0，进而产生不了波特率，一直卡在START状态，从而导致后续的数据传输出错。</p>
<p>修改后的时序如下（主要区别在<code>bps_clk</code>、<code>bps_clk_en</code>两个信号）：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220323214935876.png" alt="image-20220323214935876"></p>
<p>经测试，可以正常发送，误码率为0%！！！太不容易了/(ㄒoㄒ)/~~</p>
<blockquote>
<p>通过这个bug，得到一个教训，就是写testbench，不要觉得麻烦而随便写一个，尽量按照实际的数据产生流程来写，以便发现BUG。</p>
</blockquote>
<h3 id="BUG3："><a href="#BUG3：" class="headerlink" title="BUG3："></a>BUG3：</h3><p>解决掉数据传输的BUG后，还剩一个数据计算的BUG，这还算是一个正常的BUG。</p>
<p>BUG3的现象是，ROLL和PITCH极不稳定，反复横跳，不过经过一段时间后，ROLL会稳定下来，PITCH则仍然反复横跳。</p>
<p>测试计划：</p>
<ol>
<li>查看I2C读出的原始数据观察是否正常</li>
</ol>
<p>调试过程中还出现了一个小故障，FPGA开发板和插着MPU6050的面包板是通过杜邦线连接的，有时一动面包板就会导致I2C读不出数据，数码管显示卡住，估计是<strong>因为杜邦线的接触不良</strong>，毕竟很松动，于是改为直接插在开发板上，故障解决。</p>
<blockquote>
<p>PS：这个经验很重要！！！一定要要保证数据传输的正确性！！！</p>
</blockquote>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220324120155237.png" alt="image-20220324120155237"></p>
<p>然后惊奇地发现，ROLL数据变得正常了？！！不再反复横跳，能正确计算ROLL角度的实时变化。然后就只剩PITCH角度需要调试了。</p>
<p>等等！！！麻了，遇到一个更诡异的现象，就是，经过一段时间之后，ROLL和PITCH的情况交换了，也就是，ROLL变得反复横跳，PITCH则是能正常测量。然后。。。再过一段时间，又会交换，绝了。算了，一步一步DEBUG吧。</p>
<p>经过观察，MPU6050读出的原始数据没有问题。</p>
<p>接下来进一步DEBUG。</p>
<ol>
<li>观察原始的，未经滤波的ROLL和PITCH</li>
</ol>
<p>在经过Kalman_Iter_Unit之前，roll、pitch、gyro_x_fp、gyro_y_fp都是正常的。所以问题出在迭代部分，这次我准备先写一个tb来对Iter模块进行仿真。</p>
<p><strong>果然，tb的结果出错了</strong>，这次的情况是，开始的一段时间并没有异常，随着计算的轮数增加，PITCH越来越偏，开始反复横跳。</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220325122314295.png" alt="image-20220325122314295"></p>
<p>按照数据流向观察计算过程，发现UPDATE模块计算的divident1和K1的值很奇怪，仔细一看，发现由于K_0和K_1晚K_done一个周期，而后续的angle_temp和bias_temp的计算都会用到新的K_0、和K_1的结果，但是这里采集的仍然是老的K_0和K_1（step的上升沿），所以导致了后续结果的错误。</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220325154052927.png" alt="image-20220325154052927"></p>
<p>要解决这个问题就是把K_done延迟一个周期，修改后的结果如图：</p>
<p><img src="/2022/04/11/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%883%EF%BC%89/image-20220325172044296.png" alt="image-20220325172044296"></p>
<p>同时发现一个事实：每经过一轮更新，ROLL和PITCH的P矩阵的值都是一样的。因为P的初始值都相同，P的更新过程都是一样的。</p>
<blockquote>
<p>从这次的经验来看，好好写tb是多么重要！！！</p>
</blockquote>
<h2 id="完结撒花！！！"><a href="#完结撒花！！！" class="headerlink" title="完结撒花！！！"></a>完结撒花！！！</h2>]]></content>
      <categories>
        <category>个人项目</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>MPU6050</tag>
        <tag>姿态解算</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FPGA的MPU6050姿态解算（2）</title>
    <url>/2022/03/30/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h3 id="项目开源地址"><a href="#项目开源地址" class="headerlink" title="项目开源地址"></a>项目开源地址</h3><p><a href="https://github.com/Floral/Pose-Detection-of-MPU6050-Based-on-FPGA" target="_blank" rel="noopener">Floral/Pose-Detection-of-MPU6050-Based-on-FPGA: FPGA implementation of pose detection with Kalman filter (github.com)</a></p>
<h3 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h3><p><a href="https://zhuanlan.zhihu.com/p/490157566" target="_blank" rel="noopener">基于FPGA的MPU6050姿态解算（2） - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>个人项目</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>MPU6050</tag>
        <tag>姿态解算</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FPGA的MPU6050姿态解算（1）</title>
    <url>/2022/03/25/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>该项目仅仅是我个人的一个练手项目，为的是锻炼我的整体架构设计以及算法实现能力。</p>
<p>首先说明，该项目的设计很烂，为了“快速”完成（虽然并不快つ﹏⊂），几乎没有考虑资源的时分复用，几乎就是直译C语言的代码，因此资源消耗很大（7742个LUT）。主要是因为其中的多个定点数除法IP、开方IP，位数比较多，所以资源消耗也多。同时也没有使用流水线的机制，所以效率也不高（主要是由于UART的传输速率限制，算的再快也没用hhhhh）。</p>
<a id="more"></a>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>项目的整体架构框图如下：</p>
<p><img src="/2022/03/25/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%881%EF%BC%89/image-20220325194245903.png" alt="image-20220325194245903"></p>
<p>其中所有模块都默认连接了CLK。</p>
<h3 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h3><h4 id="clk-div"><a href="#clk-div" class="headerlink" title="clk div"></a>clk div</h4><p>给I2C模块的分频</p>
<h4 id="Keyboard-scan"><a href="#Keyboard-scan" class="headerlink" title="Keyboard scan"></a>Keyboard scan</h4><p>扫描按键，用来给Kalman ctrl发送开始信号，复位后按下一次按键以开始实时卡尔曼滤波。</p>
<h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>用于控制Kalman ctrl读取I2C数据的速率</p>
<h4 id="edge-detect"><a href="#edge-detect" class="headerlink" title="edge detect"></a>edge detect</h4><p>因为I2C模块的时钟与其他模块不一致，所以需要此模块来检测I2C master控制信号的上升沿。</p>
<h4 id="I2C-master-logic-和-I2C-buffer"><a href="#I2C-master-logic-和-I2C-buffer" class="headerlink" title="I2C master logic 和 I2C buffer"></a>I2C master logic 和 I2C buffer</h4><p>实际组成了I2C master模块。</p>
<h4 id="Kalman-Ctrl"><a href="#Kalman-Ctrl" class="headerlink" title="Kalman Ctrl"></a>Kalman Ctrl</h4><p>整个卡尔曼滤波的流程控制模块，整个流程包括一下流程：</p>
<ol>
<li>等待状态（WAIT）</li>
<li>MPU配置（CONFIG）</li>
<li>数据校正（CALIBRATE）</li>
<li>滤波计算（CALCULATE）</li>
</ol>
<h4 id="Kalman-calibration-和-Kalman-Calculate"><a href="#Kalman-calibration-和-Kalman-Calculate" class="headerlink" title="Kalman calibration 和 Kalman Calculate"></a>Kalman calibration 和 Kalman Calculate</h4><p>共同组成Kalman Filter。</p>
<p>calibration负责数据校正（计算数据偏移），Calculate负责具体的滤波计算</p>
<h4 id="data-packing"><a href="#data-packing" class="headerlink" title="data packing"></a>data packing</h4><p>执行对角度数据的封帧操作，以满足上位机的协议</p>
<h4 id="FIFO-和-UART-TX"><a href="#FIFO-和-UART-TX" class="headerlink" title="FIFO 和 UART TX"></a>FIFO 和 UART TX</h4><p>存储和传输每帧数据给上位机</p>
<blockquote>
<p>实际工程中还用了数码管动态显示的模块，只是为了测试用，可有可无。</p>
</blockquote>
<h2 id="整体计算流程"><a href="#整体计算流程" class="headerlink" title="整体计算流程"></a>整体计算流程</h2><p>整体计算流程如下图（很容易理解）：<img src="/2022/03/25/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84MPU6050%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%EF%BC%881%EF%BC%89/image-20220325203319342.png" alt="image-20220325203319342"></p>
<h2 id="第三方IP使用"><a href="#第三方IP使用" class="headerlink" title="第三方IP使用"></a>第三方IP使用</h2><h3 id="I2C-IP"><a href="#I2C-IP" class="headerlink" title="I2C IP"></a>I2C IP</h3><p>首先是I2C的IP，使用的是小脚丫社区开源的IP，本项目在该IP的基础上进行了完善和改进，以完成本项目的目标。</p>
<p>链接：<a href="https://www.stepfpga.com/doc/i2c_master_core" target="_blank" rel="noopener">i2c_master_core TEP FPGA开源社区</a></p>
<h3 id="开方IP"><a href="#开方IP" class="headerlink" title="开方IP"></a>开方IP</h3><p>使用的开方IP是vivado中自带的square root IP</p>
<h3 id="除法IP"><a href="#除法IP" class="headerlink" title="除法IP"></a>除法IP</h3><p>使用的是vivado自带的Divider Generator IP</p>
<h3 id="UART-IP"><a href="#UART-IP" class="headerlink" title="UART IP"></a>UART IP</h3><p>UART是参考的小脚丫的IP写的，链接：<a href="https://www.stepfpga.com/doc/uart_verilog" target="_blank" rel="noopener">uart_verilog STEP FPGA开源社区</a></p>
<p>通过该IP，也学到了DDS任意分频的方法👍</p>
<h3 id="CORDIC求反正切IP"><a href="#CORDIC求反正切IP" class="headerlink" title="CORDIC求反正切IP"></a>CORDIC求反正切IP</h3><p>参考的是黑金的教程中的IP</p>
]]></content>
      <categories>
        <category>个人项目</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>MPU6050</tag>
        <tag>姿态解算</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》 Ch8 Linux共享库的组织</title>
    <url>/2021/11/23/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch8-Linux%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%BB%84%E7%BB%87/</url>
    <content><![CDATA[<p>本章开始，记录的方式将变得越来越简要（以节省时间，提升更新速度），起到一个要点记录的作用。</p>
<blockquote>
<p>虽然这一章最终还是又臭又长。</p>
<p>​                                                            ——来自写完后的我</p>
</blockquote>
<p>本章主要讲的是Linux下共享库的管理、安装、查找机制以及符号版本机制。</p>
<a id="more"></a>
<h3 id="8-1-共享库版本"><a href="#8-1-共享库版本" class="headerlink" title="8.1 共享库版本"></a>8.1 共享库版本</h3><p>产生共享库需要组织的根本原因就是，不同版本的共享库的<strong>ABI（Application Binary Interface）</strong>不一样。API是源代码层面的接口，而ABI是二进制层面的接口，ABI就是API经过编译器编译后之后形成的二进制文件中的接口，由于不同版本的代码经过编译后的二进制库文件的不同，可能会改变某些ABI，进而导致不同版本的库不兼容，所以必须对不同版本的库进行管理。</p>
<blockquote>
<p>按照书上的话说，ABI包括一些诸如：函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等方面的规则。</p>
</blockquote>
<p>库函数的更新分为可兼容和不可兼容两种：</p>
<p><strong>兼容更新：</strong>在原先版本的共享库的基础上添加一些东西，并不改变原有的接口。</p>
<p><strong>不兼容更新：</strong>改变了原先版本的共享库的某些接口。</p>
<p>C语言的库函数不同更改的兼容性如下：</p>
<p>编译器和系统库的不同（甚至版本不同）都可能会影响ABI。</p>
<blockquote>
<p>C++的ABI兼容问题很严重，因为C++对其ABI并没有作出规定，所以不同的编译器甚至同一个编译器的不同版本对C++的一些特性都有着不同的方案，而且互不兼容，比如虚函数表、模板实例化、多重继承等。</p>
</blockquote>
<p>代码、编译器、操作系统等因素的影响，不同的环境下，同一份源代码编译后的ABI也可能不同。</p>
<h4 id="8-1-2-共享库版本命名"><a href="#8-1-2-共享库版本命名" class="headerlink" title="8.1.2 共享库版本命名"></a>8.1.2 共享库版本命名</h4><p>Linux的共享库命名规则如下：</p>
<p><code>libname.so.x.y.z</code></p>
<p>其中，<code>so</code>是共共享库后缀，<code>x</code>是主版本号，<code>y</code>是次版本号，<code>z</code>是发布版本号。</p>
<p>主版本号是重大升级，不同主版本之间是不兼容的</p>
<p>次版本号是增量升级，只增加了一些新的接口符号，在主版本号相同的前提下，高次版本向低次版本兼容。</p>
<p>发布版本号是一些错误的修正、性能的改进等，在主版本号和次版本号相同的情况下，不同发布版本之间完全兼容。</p>
<blockquote>
<p>Linux下也有一些不符合上述规则的特例，比如Glibc，它包含了许多部分，其中的c语言库采用的方式是：<code>libc-x.y.z.so</code>，还有动态链接器<code>ld-x.y.z.so</code>，Glibc还有其他的部分也是这样。</p>
</blockquote>
<h4 id="8-1-3-SO-NAME"><a href="#8-1-3-SO-NAME" class="headerlink" title="8.1.3 SO-NAME"></a>8.1.3 SO-NAME</h4><p>因为不同版本的共享库不一定兼容，所以每个程序中必须包含其所依赖的库的版本信息。</p>
<p>因为不同的主版本是肯定不兼容的，所以系统主要通过主版本号来区分链接的版本，这个机制称为SO-NAME，也就是创建一个指向共享库的<strong>软链接</strong>，其名字只保留共享库的主版本号，例如：“/lib/libfoo.so.2.6.1”的SO-NAME就是“/lib/libfoo.so.2”。</p>
<blockquote>
<p>由于某些历史原因，动态链接器的SO-NAME也与众不同，比如<code>ld-2.6.1.so</code>的SO-NAME是<code>ld-linux.so</code>。</p>
</blockquote>
<p>如果一个OS里有多个主版本号相同，次同版号不同的库，SO-NAME软链接会指向次版本号最新的库。</p>
<p>没有SO-NAME机制前，编译生成ELF文件时需要将所依赖的库的全名（比如<code>libfoo.2.6.1</code>）保存到<code>.dynamic</code>中，如果在新的OS环境中没有这个版本的库，就无法正常运行。</p>
<p>有了SO-NAME机制后，就可以将所依赖的库的SO-NAME保存到<code>.dynamic</code>段中，之后运行的时候，动态链接器就可以根据SO-NAME来链接到符合条件的最新的库了。</p>
<p>由于次版本号是高版本兼容低版本的，更新库的时候也可以直接删掉旧的次版本号的库了，大大节省了空间。</p>
<p>如果是主版本升级，那么OS中会保存有多个SO-NAME。</p>
<blockquote>
<p>Linux中的<code>ldconfig</code>工具，可以遍历所有默认的共享库目录（<code>lib</code>、<code>/usr/lib</code>），来更新所有SO-NAME的软链接的，使其指向最新的版本库。</p>
</blockquote>
<p><strong>链接名</strong></p>
<p>GCC编译器可以用<code>-l</code>参数使用某个共享库，具体请用看GCC的帮助或百度，这里不再赘述。</p>
<h3 id="8-2符号版本"><a href="#8-2符号版本" class="headerlink" title="8.2符号版本"></a>8.2符号版本</h3><p>虽然SO-NAME是指向了本机器上最新的此版本号的库，但是存在这种情况：在其他机器上编译的软件依赖的库的次版本号（2.7.1）比运行该软件的环境中库的次版本号高（2.6.1），虽然SO-NAME一样，但是如果直接运行该软件的话，仍然有可能报错，因为该软件可能用到了高次版本库更新的符号。这个问题称作<strong>“次版本号交会问题”</strong></p>
<p>有些OS会直接向用户发出警告但继续运行，有些OS则是直接禁止运行该软件。</p>
<p>为了更细致的控制符号的版本依赖问题，出现了一种<strong>基于符号的版本机制（Symbol Versioning）</strong>。思想就是给每个符号打上版本标记，比如“VERS_1.1”、“VERS_1.2”。</p>
<h4 id="8-2-2-Solaris中的符号版本机制"><a href="#8-2-2-Solaris中的符号版本机制" class="headerlink" title="8.2.2 Solaris中的符号版本机制"></a>8.2.2 Solaris中的符号版本机制</h4><p>符号的版本标记也可以看作一种集合，Solaris中程序员可以通过<strong>符号版本脚本</strong>来指定符号所属的集合，集合与几何之间也存在继承和以来的关系。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUNW_1.2 &#123;</span><br><span class="line">	global:</span><br><span class="line">	swap;</span><br><span class="line">&#125;SUNW_1.1;</span><br><span class="line"></span><br><span class="line">SUNW_1.1 &#123;</span><br><span class="line">	global:</span><br><span class="line">	pop;</span><br><span class="line">	push;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SUNWprivate &#123;</span><br><span class="line">	global:</span><br><span class="line">	__pop;</span><br><span class="line">	__push;</span><br><span class="line">	local:</span><br><span class="line">	*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个脚本中定义了3个集合：”SUNW_1.2“、”SUNW_1.1“和”SUNWprivate“，第一个集合有一个全局符号<code>swap</code>，同时继承了SUNW_1.1集合中的所有符号，SUNW_1.1中包含了<code>pop</code>和<code>push</code>两个全局符号，SUNWprivate中则声明了<code>__pop</code>和<code>__push</code>这两个全局符号，同时将其他所有的符号（除了这3个集合中声明过的全局符号）都声明为局部符号。</p>
<p>这种方法又被称为<strong>范围机制（Scoping）</strong>。</p>
<h4 id="8-2-3-Linux中的符号版本"><a href="#8-2-3-Linux中的符号版本" class="headerlink" title="8.2.3 Linux中的符号版本"></a>8.2.3 Linux中的符号版本</h4><p>Linux下用符号版本机制用的并不广泛，主要是用共享库符号版本机制的是Glibc中的共享库。</p>
<p>GCC对Solaris的符号版本机制有扩展，可以在C/C++的源代码中嵌入汇编指令，一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">".symver add, add@VERS_1.1"</span>);	<span class="comment">// 把add添加到VERS_1.1的集合中，同时命名为add</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个机制允许在不同的符号版本中存在相同的符号命名，类似于符号重载，一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">".symver old_printf, printf@VERS_1.1"</span>);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">".symver new_printf, printf@VERS_1.2"</span>);	<span class="comment">//外部的程序可以根据符号版本的不同来访问不同版本的printf</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">old_printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书中有一个Linux符号版本机制的实验，可以看看。</p>
<h3 id="8-3-共享库系统路径"><a href="#8-3-共享库系统路径" class="headerlink" title="8.3 共享库系统路径"></a>8.3 共享库系统路径</h3><p>Linux一般都遵守FHS（File Hierarchy Standard），它规定了系统中的系统文件该如何存放、组织。</p>
<p>FHS中规定的共享库的存放目录如下：</p>
<ul>
<li>/lib：最关键的和最基础的共享库，如动态链接器，C语言运行库、数学库，这些是系统工具/运行的基础</li>
<li>/usr/lib：非系统运行时所需要的关键性的共享库，主要是开发时用到的库</li>
<li>/usr/local/lib：主要是第三方应用的库，例如python的解释器</li>
</ul>
<h3 id="8-4-共享库查找过程"><a href="#8-4-共享库查找过程" class="headerlink" title="8.4 共享库查找过程"></a>8.4 共享库查找过程</h3><p>一个动态连接的模块所依赖的共享库的路径保存在<code>.dynamic</code>段里面，由<code>DT_NEED</code>类型的项表示。如果保存的是绝对路径，就直接按照这个去找；如果是相对路径，那么动态链接器就会在<code>/lib</code>、<code>/usr/lib</code>和<code>/etc/ld.so.conf</code>配置文件中指定的目录去查找共享库。</p>
<p>我的wsl中的<code>/etc/ld.so.conf</code>文件内容是：<code>include /etc/ld.so.conf.d/*.conf</code>，也就是说包含了<code>/etc/ld.so.conf.d/</code>目录下所有后缀名为<code>conf</code>的配置文件的内容，具体可以进一步查看这些文件中包含的目录。</p>
<p>Linux中有一个<code>ldconfig</code>程序，可以搜索这些目录中的库，然后更新相应的SO-NAME（需要该库指定了它自己的SO-NAME），并且存放到一个缓存中，就可以加速共享库的查找过程。每当修改了<code>ld.so.conf</code>包含的内容或者手动安装了库，都应该运行一下这个程序（用包管理器安装的一般会自动帮你运行。</p>
<h3 id="8-5-环境变量"><a href="#8-5-环境变量" class="headerlink" title="8.5 环境变量"></a>8.5 环境变量</h3><p>环境变量，简单来说就是可以类比为变成中的变量，只不过这个变量的作用域是整个计算机系统。</p>
<p>同时，环境变量主要用来指示系统中一些“环境”的安装位置，比如各种编程语言的编译环境（例如Python、C++），或者是系统查找动态链接库的目录（比如<code>LD_LIBRARY_PATH</code>、<code>LD_PRELOAD</code>）。</p>
<blockquote>
<p>PS：由于加载的全局符号会覆盖后加载的同名全局符号，<code>LD_PRELOAD</code>可以用来修改某些库的某些函数，经常被用在调试或测试中。</p>
<p>书中还提到了一个<code>LD_DEBUG</code>环境变量，可以用来开启动态链接器的调试功能。</p>
</blockquote>
<h3 id="8-6-共享库的创建和安装"><a href="#8-6-共享库的创建和安装" class="headerlink" title="8.6 共享库的创建和安装"></a>8.6 共享库的创建和安装</h3><h4 id="8-6-1-共享库的创建"><a href="#8-6-1-共享库的创建" class="headerlink" title="8.6.1 共享库的创建"></a>8.6.1 共享库的创建</h4><p>创建很简单，就是之前讲过的生成动态链接库的过程，一个典型的命令是：</p>
<p><code>$gcc -shared -Wl,-soname,my_soname -o library_name source_files library_files</code></p>
<p>即，产生一个名为<code>library_name</code>的共享库，它的so-name是<code>my_soname</code>，它的源文件包括<code>source_files</code>，它依赖<code>library_files</code>这些库文件。</p>
<blockquote>
<p><code>-Wl</code>参数用来把参数传递给链接器，这里就是传递soname参数，如果不指定soname，那么<code>ldconfig</code>命令就不会查找和更新这个库的soname了。</p>
</blockquote>
<h4 id="8-6-2-清除符号信息"><a href="#8-6-2-清除符号信息" class="headerlink" title="8.6.2 清除符号信息"></a>8.6.2 清除符号信息</h4><p>普通编译的共享库或可执行文件里面带有符号信息和调试信息，对于最终发布的版本来说，这些信息没什么用，所以可以用<code>strip</code>工具来清除掉这些信息（或者向链接器传递<code>-s</code>和<code>-S</code>参数使得生成的时候就不产生这些信息）。</p>
<blockquote>
<p><code>-s</code>是清除所有符号信息，<code>-S</code>是清除调试符号信息。</p>
</blockquote>
<h4 id="8-6-3-共享库的安装"><a href="#8-6-3-共享库的安装" class="headerlink" title="8.6.3 共享库的安装"></a>8.6.3 共享库的安装</h4><p>方法一：把共享库放在某个标准的系统共享库目录下，比如：/lib、/usr/lib等，然后运行ldconfig就行。（此方法需要root权限</p>
<p>方法二：手动建立SO-NAME（<code>ldconfig -n shared_library_directory</code>），然后编译的时候告诉编译器和程序该去哪查找共享库（比如设置<code>LD_LIBRARY_PATH</code>环境变量）。</p>
<h4 id="8-6-4-共享库构造和析构函数"><a href="#8-6-4-共享库构造和析构函数" class="headerlink" title="8.6.4 共享库构造和析构函数"></a>8.6.4 共享库构造和析构函数</h4><p>关于构造函数和析构函数的概念，在第四章的笔记中提到过。</p>
<p>GCC对C/C++语言进行了扩展，可以使用<code>__attribute__((constructor))</code>和<code>__attribute__((deconstructor))</code>来分别生命构造和析构函数。</p>
<p>还有可以指定优先级，例如：<code>__attribute__((constructor(5)))</code></p>
<p>具体用法请使用的时候再搜索</p>
<h4 id="8-6-5-共享库脚本"><a href="#8-6-5-共享库脚本" class="headerlink" title="8.6.5 共享库脚本"></a>8.6.5 共享库脚本</h4><p>链接脚本有时候也可以看作一个共享库，需要符合一定的格式。比如<code>libfoo.so</code>文件的内容就是一句脚本：<code>GROUP(/lib/libc.so.6 /lib/libm.so.2)</code>，这个共享库相当于是把<code>libc</code>和<code>libm</code>这两个库组合成一个了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>《程序员的自我修养》</tag>
        <tag>共享库</tag>
        <tag>符号版本</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>DELL R730服务器系统安装及EDA软件安装</title>
    <url>/2021/10/09/DELL-R730%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8AEDA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>实验室服务器是DELL R730</p>
<h2 id="服务器系统安装"><a href="#服务器系统安装" class="headerlink" title="服务器系统安装"></a>服务器系统安装</h2><p>我安装的是Ubuntu18.04，也可安装16.04</p>
<a id="more"></a>
<p>基本步骤：</p>
<p><strong>0.</strong>用rufus制作启动U盘</p>
<p><strong>1.</strong>对磁盘进行RAID配置，设置虚拟盘（如果已经设置过的可以不用重新设置）</p>
<p><strong>2.</strong>进入服务器BIOS，切换boot方式为UEFI（磁盘大于2TB的话不支持BIOS启动），硬盘模式为RAID</p>
<p><strong>3.</strong>重启，通过U盘启动，进入系统安装流程</p>
<p>可以参考如下Blog：</p>
<p><a href="https://zhuanlan.zhihu.com/p/348219472" target="_blank" rel="noopener">Dell R730安装Ubuntu 18.04的过程 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qingfengleerge/article/details/82855192" target="_blank" rel="noopener">戴尔PowerEdge R730服务器通过U盘启动的方式安装Windows Server 2016_起风了二哥-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/love-sherry/p/7216242.html#:~:text=服务器（Dell poweredge r730）安装Ubuntu步骤： 开机进入BIOS，进行RAID设置；或者进入服务器管理系统中设置RAID。 开机后当出现&lt;,Ctrl &gt; 时按Ctrl%2Br，进入小型BIOS，如图1 所示： 注1：将光标指在此处根据下方提示按F2设置RAID。" target="_blank" rel="noopener">Dell PowerEdge r730的配置以及Linux系统安装 - 枫兮云兮君兮 - 博客园 (cnblogs.com)</a></p>
<h2 id="EDA软件安装"><a href="#EDA软件安装" class="headerlink" title="EDA软件安装"></a>EDA软件安装</h2><p>基本步骤可参考如下Blog：</p>
<p><a href="https://blog.csdn.net/qq_33589780/article/details/108720685" target="_blank" rel="noopener">数字IC设计的第一步——Synopsys EDA Tools的安装_WeelCJ的博客-CSDN博客</a></p>
<p>需要注意的点有：</p>
<p><strong>0.</strong>建议installer和其他安装包可以分开放</p>
<p><strong>1.</strong>新建文件夹的时候注意当前用户是否具有文件夹的权限，如果没有的话，会在使用installer安装过程中遇到没有权限写文件夹的错误</p>
<p><strong>2.</strong>Ubuntu18.04在运行<code>lmhostid</code>和其他License工具的时候会出现<code>bash: ./lmhosid: No such file or dictionary</code>，即使安装了LSB（Linux Standard Base），仍然会提示这个错误，网上找到的直接解决方案除了重装Ubuntu16.04之外没有其他的了。但是我实在不想重装了，在网上查找了一番，<strong>发现是缺少了<code>ld-lsb.so.3</code>这个动态链接器(<a href="https://developer.arm.com/documentation/ka003732/latest" target="_blank" rel="noopener">LICENSE: Lmgrd on Linux Fails with “No such file or directory” (arm.com)</a>)</strong>，经过进一步搜索，解决方法就是添加一个名为<code>ld-lsb.so.3</code>的软链接，链接到<code>ld-linux.so.2</code>上，如下：</p>
<blockquote>
<p><a href="https://askubuntu.com/questions/1367443/where-can-i-find-lib-ld-lsb-so-3-for-ubuntu-21-04" target="_blank" rel="noopener">package management - Where can I find /lib/ld-lsb.so.3 for Ubuntu 21.04? - Ask Ubuntu</a></p>
<p>(ˉ▽ˉ；)…</p>
<p>PS：回想起《程序员的自我修养》中讲到的知识，运行动态链接的程序最开始会启动动态链接器来完成动态链接，当动态链接器找不到的时候，当然会报<code>No such file or dictionary</code>啦！而且不像缺动态库的报错，并不会提示缺什么东西。</p>
<p>PPS：运行软件的时候缺各种动态库的根本原因是需要运行的程序是老版本的Linux下编译的ELF文件，依赖的库的版本不一样</p>
</blockquote>
<p><strong>3.</strong>HostID其实就是网卡的MAC，服务器上有多个网卡，注意选择连接网线的那一个，然后要把那个网卡名修改为<code>eth0</code>，这里没有用上面的Blog的方法，而是通过<code>Ubuntu18.04</code>及以上版本新的工具<code>netplan</code>来修改，netplan的官网是：<a href="https://netplan.io/reference/" target="_blank" rel="noopener">Netplan | Backend-agnostic network configuration in YAML</a>，从中可知它是通过目录<code>/etc/netplan</code>下的所有<code>yaml</code>配置文件来配置网络的，如果你的机器上没有的话可以自己新建一个，有的话直接修改第一个的内容就行。修改后的配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">eth0:</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">match:</span></span><br><span class="line">                <span class="attr">macaddress:</span> <span class="string">xx:xx:xx:xx:xx:xx</span>	<span class="comment"># 这里是你机器需要修改名称的网卡的mac地址</span></span><br><span class="line">            <span class="attr">set-name:</span> <span class="string">eth0</span></span><br><span class="line">            <span class="comment"># 至少包含以上的条目就行</span></span><br></pre></td></tr></table></figure>
<p>​        然后<code>netplan apply</code>就行。<a href="https://cloud.tencent.com/developer/article/1699857" target="_blank" rel="noopener">Ubuntu 18.04 LTS 通过 Netplan 配置网络教程 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><strong>4.</strong>如果安装or执行程序的过程中遇到缺少动态链接库的情况，直接百度错误提示即可，上面的Blog也已经写出了许多会遇到的问题（赞👍</p>
<blockquote>
<p>暂时只想起来这些问题，以后想起来再补充吧</p>
</blockquote>
]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>打工人的日常</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>系统安装</tag>
        <tag>lmhostid</tag>
        <tag>lmgrd</tag>
      </tags>
  </entry>
  <entry>
    <title>包含共享库时动态链接编译的搜索路径问题——《程序员的自我修养》7.6.2示例的问题</title>
    <url>/2021/07/12/%E5%8C%85%E5%90%AB%E5%85%B1%E4%BA%AB%E5%BA%93%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%BC%96%E8%AF%91%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文内容基于《程序员的自我修养》7.6.2小节的示例。</p>
<a id="more"></a>
<p>首先，按照书上写的命令一顿敲：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared a1.c -o a1.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared a2.c -o a2.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared b1.so a1.so -o b1.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared b2.so a2.so -o b2.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.c b1.so b2.so -o main -Xlinker -rpath ./</span></span><br></pre></td></tr></table></figure>
<p>开开心心地运行：<code>./main</code>，然后，就出现了这一行：</p>
<p><code>./main: error while loading shared libraries: a1.so: cannot open shared object file: No such file or directory</code></p>
<p>顿时懵逼。</p>
<p>书上不是说加了<code>-Xlinker -rpath ./</code>就不会报错嘛？（这个三个参数是在编译时通知链接器  额外的共享库的搜索路径，以至于在编译以及运行时不会出现找不到共享库的问题）</p>
<p>但，为什么还是出了问题呢？可能是由于OS、GCC以及动态链接器版本不同问题？毕竟书的年代有些久远。</p>
<blockquote>
<p>PS：我的OS是Ubuntu 20.04.1 LTS on Windows 10 x86_64，GCC版本为9.3.0，ld为2.34</p>
</blockquote>
<p>经过我对前文不断尝试，终于理解了gcc编译链接共享库以及运行时查找共享库的机制。</p>
<p>我们一行命令一行命令来看，首先前两行是没有问题的，因为<code>a1.so</code>和<code>a2.so</code>没有依赖其他的共享库。问题出在第3、4行。</p>
<p>执行完第3、4行命令之后，通过<code>ldd</code>命令查看<code>b1.so</code>和<code>b2.so</code>的共享库依赖情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd b1.so</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff08e5000)</span><br><span class="line">        a1.so =&gt; not found</span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd b2.so</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffde39a0000)</span><br><span class="line">        a2.so =&gt; not found</span><br></pre></td></tr></table></figure>
<p>因为<code>ldd</code>是调用标准的动态链接器（<code>ld.so</code>）来查找共享库依赖的，所以用ldd查看的结果就代表你运行时的查找结果，所以这个<code>not found</code>就说明了问题，正好对应上面运行<code>./main</code>报的错。</p>
<p>更进一步，用<code>readelf -d</code>查看<code>b1.so</code>和<code>b2.so</code>的<code>.dynamic</code>段，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -d ./b1.so</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x2e50 contains 21 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [a1.so]</span><br><span class="line"> 0x000000000000000c (INIT)               0x1000</span><br><span class="line"> 0x000000000000000d (FINI)               0x1130</span><br><span class="line">...	//后面的省略</span><br><span class="line"> </span><br><span class="line"><span class="meta"> $</span><span class="bash"> readelf -d ./b2.so</span></span><br><span class="line"> Dynamic section at offset 0x2e50 contains 21 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [a2.so]</span><br><span class="line"> 0x000000000000000c (INIT)               0x1000</span><br><span class="line"> 0x000000000000000d (FINI)               0x1130</span><br><span class="line">...	//后面的省略</span><br></pre></td></tr></table></figure>
<p>这里只说明了依赖的共享库的名字，并没有指明路径，所以在运行的时候<code>ld.so</code>只会按照系统的路径搜索，其并不会搜索当前路径。查看<code>main</code>的<code>.dynamic</code>段，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -d ./main</span></span><br><span class="line">Dynamic section at offset 0x2d90 contains 30 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [b1.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [b2.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000001d (RUNPATH)            Library runpath: [./]</span><br><span class="line"> 0x000000000000000c (INIT)               0x1000</span><br><span class="line"> 0x000000000000000d (FINI)               0x1208</span><br><span class="line">...	//后面的省略</span><br></pre></td></tr></table></figure>
<p>一个重要的区别，就是第7行的<code>Library runpath: [./]</code>，这里指示了运行时的共享库搜索路径，但是为什么还是找不到<code>a1.so</code>（和<code>a2.so</code>）呢？因为<code>main</code>中的<code>.dynamic</code>段只显示依赖了<code>b1.so</code>和<code>b2.so</code>，在加载了<code>b1.so</code>和<code>b2.so</code>之后，需要继续搜索<code>a1.so</code>和<code>a2.so</code>，这时只会按照<code>b1.so</code>和<code>b2.so</code>中<code>.dynamic</code>段的信息来搜索，而其中并没有指示额外的运行时搜索路径<code>runpath</code>，所以就出现了找不到<code>a1.so</code>的报错。</p>
<p>要解决这个问题，就是要通知<code>ld.so</code>  <code>b1.so</code>和<code>b2.so</code>运行时依赖的共享库的搜索路径。</p>
<p>因为Linux下运行时查找共享库的路径是有固定位置和顺序的（位置可以手动修改），这个在第8章中会讲到，系统默认的位置是不包括当前目录<code>./</code>的，所以你要手动告诉<code>ld.so</code>共享库的搜索路径包括当前路径<code>./</code>，告诉的方法有很多种（在第8章中会详细说明），这里只讲一种简单的，就是像编译<code>main</code>的时候一样，在结尾添加<code>-Xlinker -rpath ./</code>参数（或者用<code>-Wl</code>参数也行，请自行百度）。</p>
<blockquote>
<p>PS：这个示例用的都是相对地址，这样得到的可执行程序（例如<code>main</code>）只能在编译的路径下运行，假如将这个程序复制到其他路径运行，那么仍然会报找不到共享库的错，所以在写做一个工程项目的时候，都是将共享库安装到一个专门的路径下，然后使用绝对路径来搜索（其他方法在第8章中会讲到）。</p>
</blockquote>
]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>动态链接</tag>
        <tag>共享库搜索路</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》Ch7动态链接（下）</title>
    <url>/2021/06/24/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8BCh7%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="7-4-延迟绑定（PLT）"><a href="#7-4-延迟绑定（PLT）" class="headerlink" title="7.4 延迟绑定（PLT）"></a>7.4 延迟绑定（PLT）</h3><p>由前可知，GOT相比静态链接，增加了灵活性，但是降低了运行的速度（因为多了运行时重定位的过程）。同时，因为要在真正运行程序前将程序引用到的所有函数都进行动态链接，这个过程很耗时，导致用户在点击运行程序后需要等待的时间变长，影响用户体验（用户就是上帝！）。</p>
<a id="more"></a>
<p>同时，考虑到一个事实，那就是：在我们实用程序的时候，并不是所有在程序中被引用的函数都真正被调用了（比如if判断就会导致有些函数不会被调用）。于是考虑，能不能在函数第一次被调用的时候才对函数进行链接，这样也能将原本的时间（一次性链接所有函数）平摊到每次调用函数的时候——一个函数第一次链接所需要的时间很少，使得用户体验得到明显提升。</p>
<p>这种方案称作<strong>延迟绑定（Lazy Binding）</strong>，基本思想就是在<strong>函数第一次被用到的时候才进行绑定</strong>（符号查找、重定位等），这样可以大幅提高程序的启动速度。</p>
<p>ELF具体使用的是<strong>PLT（Procedure Linkage Table）</strong>方法，在ELF文件中表现为段名中包含<code>plt</code>的段，其本质就是在指令和GOT之间又增加了一层跳转的过程，在第一次调用的时候，调用一个“绑定函数”来完成函数的绑定过程（填充GOT表中的项），在之后的调用时，直接调用GOT表中的项。每一个函数都在<code>plt</code>中有一个对应的项。</p>
<p>动态链接器绑定过程具体调用的方法是<code>_dl_runtime_resolve()</code>，它需要的两个参数：</p>
<ol>
<li>这个函数绑定发生在哪个模块（module）</li>
<li>需要绑定的是哪个函数（function）</li>
</ol>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>我们在<code>liba.so</code>模块中调用了<code>bar()</code>函数，则会调用<code>.plt</code>段中的bar项，具体表示为（<code>bar@plt</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)	; bar@GOT表示bar在GOT中的项的地址</span><br><span class="line">push n			; n是bar这个符号在.rel.plt段中的下标，用以查询符号名</span><br><span class="line">push moduleID	; moduleID是调用bar的模块的ID</span><br><span class="line">jump _dl_runtime_resolve	; 最后三句是函数调用过程</span><br></pre></td></tr></table></figure>
<p>需要注意的是，第二行的<code>*(bar@GOT)</code>在未初始化时（第一次调用bar之前），指向的是第三行的地址（也就是<code>push n</code>），当执行了<code>_dl_runtime_resolve_</code>之后，<code>*(bar@GOT)</code>的值就被修改为<code>bar</code>真正的地址了。后续再调用<code>bar</code>函数的时候，就不会执行后面三句了，同时<code>bar</code>函数的返回地址也是堆栈中EIP保存的函数调用者的地址了，而不是<code>push n</code>。</p>
<p>实际的ELF中，GOT被拆成了<code>.got</code>和<code>.got.plt</code>两个段，前者是用来保存<strong>全局变量</strong>引用的地址，后者是用来保存<strong>函数引用</strong>的地址。</p>
<p>为了减少<code>.plt</code>中代码的重复，该段把每一项（上面的例子）中最后两句单独提取出来，同时把所需要的值（<code>moduleID</code>和<code>_dl_runtime_resolve_</code>）放在了<code>.got.plt</code>段的开头，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PLT0:</span><br><span class="line">push *(GOT+4)	; 这里的GOT其实指的是.got.plt的起始地址</span><br><span class="line">push *(GOT+8)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)	; 这里的GOT同理是.got.plt中的bar项的地址</span><br><span class="line">push n</span><br><span class="line">jump PLT0</span><br></pre></td></tr></table></figure>
<p><code>.got.plt</code>的内容如图（<code>.plt</code>未画出）：</p>
<p><img src="/2021/06/24/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8BCh7%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8B%EF%BC%89/7.5-GOT%E4%B8%ADPLT%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="7.5-GOT中PLT的数据结构" style="zoom: 33%;"></p>
<center>图7-5 GOT中PLT的数据结构</center>

<blockquote>
<p>PS：<code>.got.plt</code>的第一项是<code>.dynamic</code>段的地址，这个段描述了本模块动态连接的相关信息。后面的小节会讲一下这个段。</p>
<p>PPS：实际的ELF中还有<code>.plt</code>、<code>.plt.got</code>这两个段，与上面提到的<code>.got</code>、<code>.got.plt</code>很容易弄混，这四个段的区别的作用可以看一个Blog：<a href="https://www.codeleading.com/article/37234101170/" target="_blank" rel="noopener">计算机系统篇之链接（14）：.plt、.plt.got、.got 和 .got.plt section 之间的区别 - 代码先锋网 (codeleading.com)</a>，感觉写得不错。</p>
</blockquote>
<h3 id="7-5-动态链接相关结构"><a href="#7-5-动态链接相关结构" class="headerlink" title="7.5 动态链接相关结构"></a>7.5 动态链接相关结构</h3><p>动态链接的简要流程是：1. OS加载可执行文件头，读取Segment的属性，将它们映射到进程的虚拟地址空间中；2. OS将CPU的控制权交给<strong>动态链接器（Dynamic Linker）</strong>，由其完成程序的动态链接过程；3. 完成动态链接工作之后，将控制权交给可执行文件的入口地址。</p>
<h4 id="7-5-1-“-interp”段"><a href="#7-5-1-“-interp”段" class="headerlink" title="7.5.1 “.interp”段"></a>7.5.1 “.interp”段</h4><p>这个段的内容是一个字符串，保存的是可执行文件用到的动态链接器的路径。</p>
<p>用<code>objdump -s xxx</code>即可查看xxx的不同段的内容，如果xxx是动态链接的可执行程序，那么就能找到<code>.interp</code>段的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Contents of section .interp:</span><br><span class="line"> 0318 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-</span><br><span class="line"> 0328 7838362d 36342e73 6f2e3200           x86-64.so.2.</span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-“-dynamic”段"><a href="#7-5-2-“-dynamic”段" class="headerlink" title="7.5.2 “.dynamic”段"></a>7.5.2 “.dynamic”段</h4><p>“.dynamic”段是ELF动态链接中最重要的结构了，它保存了动态链接器完成动态链接（中的重定位）所需要的基本信息，包括但不限于：依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。这个段是一个结构体数组，该结构体的定义（定义在<code>elf.h</code>中）为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word_d_val;</span><br><span class="line">        Elf32_Addr_d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>其中<code>d_tag</code>指代的是一项的类型，<code>d_un</code>是一项的值。这里的类型就包括了上面所说的那些信息，比如<code>d_tag</code>为<code>DT_SYMTAB</code>，则<code>d_un</code>的值就是的信息是动态链接符号表的地址。还有其他的类型，请看书P205或搜索。</p>
<blockquote>
<p>Linux中有一个<code>ldd</code>命令，可以查看一个可执行程序/共享对象依赖的共享库</p>
</blockquote>
<h4 id="7-5-3-动态符号表"><a href="#7-5-3-动态符号表" class="headerlink" title="7.5.3 动态符号表"></a>7.5.3 动态符号表</h4><p>动态链接中，一个模块<code>A</code>引用了模块<code>B</code>的函数<code>foobar</code>，那么称<code>foobar</code>为模块<code>A</code>的<strong>导入函数（Import Function）</strong>，为模块<code>B</code>的<strong>导出函数（Export Function）</strong>。导入/导出函数可以分别看作函数的引用和定义。</p>
<p>采用了动态连接的可执行文件/库，除了包含前面静态链接中提到过的符号表“.symtab”，还包含了针对动态连接的模块之间的符号导入导出关系的<strong>动态符号表（Dynamic Symbol Table）</strong>，名为<code>.dynstr</code>的段。</p>
<p>用<code>readelf -s</code>可以查看程序的<code>.symtab</code>和<code>.dynstr</code>。</p>
<h4 id="7-5-4-动态链接重定位表"><a href="#7-5-4-动态链接重定位表" class="headerlink" title="7.5.4 动态链接重定位表"></a>7.5.4 动态链接重定位表</h4><p>与静态链接中的重定位表类似，动态链接也有相应的重定位表——<code>.rel.dyn</code>和<code>.rel.plt</code>，前者是对数据的修正，后者是对函数引用的修正。</p>
<blockquote>
<p>即使是PIC编译的共享对象，也需要重定位，只不过代码部分不用重定位，但是数据部分仍然需要（如GOT表）。</p>
</blockquote>
<h4 id="7-5-5-动态链接时进程堆栈初始化信息"><a href="#7-5-5-动态链接时进程堆栈初始化信息" class="headerlink" title="7.5.5 动态链接时进程堆栈初始化信息"></a>7.5.5 动态链接时进程堆栈初始化信息</h4><p>在动态链接器接手CPU的控制权之后，为了进行动态链接，它需要知道该文件的基本信息，包括：有几个段（Segment）、每个段（Segment）的属性、程序的入口地址等，以装载可执行文件/共享对象。由前文6.4节可知，这些信息来源于文件的执行视图，可通过<strong>程序头（Program Header）</strong>获取。</p>
<p>进程初始化的堆栈里面就包含了程序头以及可执行文件的信息，这些信息构成了<strong>辅助信息数组（Auxiliary Vector）</strong>，如：可执行文件的文件句柄、程序头的地址、程序头中入口（Entry）的数量和每个的大小、可执行文件的入口地址等等。这个数组的元素的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> a_type;	<span class="comment">//该项的类型</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> a_val;	<span class="comment">//该项对应的值</span></span><br><span class="line">    &#125;a_un;</span><br><span class="line">&#125;Elf32_auxv_t;</span><br></pre></td></tr></table></figure>
<p>也是键值对的形式（为什么有一个union是历史遗留的原因）。</p>
<p>这个数组具体的位置是在环境变量指针的后面（环境变量指针在程序输入参数的后面，也就是argc以及argv所指向的内容的后面。</p>
<blockquote>
<p>这一小节的示例代码（P213）在我的机器上并不能正常运行，需要经过修改，修改的时候对底层的原理有些疑问，等有空了再写一篇Blog详细解释一下</p>
</blockquote>
<h3 id="7-6-动态链接的步骤和实现"><a href="#7-6-动态链接的步骤和实现" class="headerlink" title="7.6 动态链接的步骤和实现"></a>7.6 动态链接的步骤和实现</h3><p>动态链接主要分为3步：启动动态链接器本身、装载所有依赖的共享对象、重定位和初始化。</p>
<h4 id="7-6-1-动态链接器自举"><a href="#7-6-1-动态链接器自举" class="headerlink" title="7.6.1 动态链接器自举"></a>7.6.1 动态链接器自举</h4><p>由于动态链接器本身就是为了给其他可执行文件or共享对象提供动态连接的功能，所以它不能自己动态链接自己，这是一个鸡生蛋、蛋生鸡的问题。虽然动态链接器本身是静态链接的（可以用<code>ldd</code>命令查看），但是其中的全局变量和静态变量仍然需要重定位，可能因为是绝对寻址的，所以需要跟据装载地址调整地址，这个过程叫做动态链接器的<strong>自举（Bootstrap）</strong>，在这个过程中，执行的代码不能用到全局变量和静态变量，也不能调用函数。完成自举之后，就能随意使用了。</p>
<h4 id="7-6-2-装载共享对象"><a href="#7-6-2-装载共享对象" class="headerlink" title="7.6.2 装载共享对象"></a>7.6.2 装载共享对象</h4><p>当一个新的共享对象被装载到内存中时，它的符号表会被合并到<strong>全局符号表（Global Symbol Table）</strong>中（包括动态链接器和可执行文件的符号表），对共享对象的依赖关系可以看作一个图的数据结构，所以装入顺序分为深度优先和广度优先，一般采用的是广度优先的方法。</p>
<p>这里存在一个可能的问题，就是不同的共享对象中的符号可能存在重复的情况，处理的方式是，哪一个符号最先被加载，哪一个就有效，其余的符号都会被解析为第一个被加载的同名符号（C语言出现同名的概率要大一些，C++的命名空间机制namespace大大减少了同名符号的可能性）。这种处理方式表明了<strong>符号的优先级</strong>。</p>
<h4 id="7-6-3-重定位和初始化"><a href="#7-6-3-重定位和初始化" class="headerlink" title="7.6.3 重定位和初始化"></a>7.6.3 重定位和初始化</h4><p>这个阶段，动态链接器开始遍历可执行程序以及每个对象的重定位表，对GOT/PLT等结构中需要重定位的地方进行重定位。</p>
<p>然后就是执行不同共享对象的初始化代码（如果有的话），初始化代码位于<code>.init</code>段中。值得注意的是，可执行程序的<code>.init</code>代码并不是由链接器执行的，而是由程序初始化部分代码负责（后面的章节会讲）。</p>
<h4 id="7-6-4-Linux动态链接器实现"><a href="#7-6-4-Linux动态链接器实现" class="headerlink" title="7.6.4 Linux动态链接器实现"></a>7.6.4 Linux动态链接器实现</h4><p>Linux动态链接器既是一个共享对象，也是一个可执行程序。</p>
<blockquote>
<p>共享库和可执行文件实际上没有什么区别，除了头文件的标志位和扩展名有所不同之外，其他都是一样的。</p>
<ul>
<li>动态链接器本身是静态链接的，且不依赖于其他共享对象。</li>
<li>动态链接器一般是PIC的，为了代码段能够共享。</li>
<li><code>ld.so</code>的文件中标明的装载地址是<code>0x00000000</code>。这是一个无效地址，在装载的时候OS会为其选择一个合适的装载地址。</li>
</ul>
</blockquote>
<h3 id="7-7-显示运行时链接"><a href="#7-7-显示运行时链接" class="headerlink" title="7.7 显示运行时链接"></a>7.7 显示运行时链接</h3><p>以上讲的都是动态链接时动态链接器对共享对象的自动装载，还有一种更灵活的方法是由程序员决定的“手动装载”，就是在代码中显示地调用系统提供的API来加载一个共享对象，这个被加载的共享对象也称作<strong>动态装载库（Dynamic Loading Library）</strong>，只是看待的角度不同。</p>
<p>这种机制可以用来实现<strong>插件</strong>的效果。当用到某个模块的时候，才将该模块装载到内存中，不需要的时候也可以调用API进行卸载，可以很好的利用有限的内存空间。</p>
<p>书中主要介绍了由动态链接器提供的4个API：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）、关闭动态库（dlclose）。这些API位于<code>dlfcn.h</code>头文件中（Linux下）。Windows也提供了<code>rundll</code>这个程序用来实现动态装载的功能。7.7.5小节还写了一个演示程序，值得看一看。</p>
<blockquote>
<p>PS：如果直接在你自己的电脑上运行的话，很大可能会报错，因为书上的代码是十多年前的版本了，还是32位，现在早已经是64位的天下了，且API早已更新了很多版（待我有时间的时候写一版目前可运行的版本。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>动态链接</tag>
        <tag>延迟绑定（PLT）</tag>
        <tag>显示装载</tag>
        <tag>运行时装载</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动一面总结</title>
    <url>/2021/04/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本人目前大四，保研本校。本想着暑假找个实习，正巧BOSS直聘上有一位前辈问我有没有意愿尝试一下测试开发岗位（基础架构部门）。可能是我没有表达清楚，结果前辈帮我投的是校招/(ㄒoㄒ)/~~（还是怪我没有说清楚。。。不过我跟hr说我想投的是暑假实习岗，他说我可以跟面试官商量，先面面看。。。）</p>
<a id="more"></a>
<p>然后自己抱着就是为了涨涨面试的经验的心态，没有认真复习准备，约等于裸面（就是当天面试下午看了几个高频面试题，千万不要学我）。。。</p>
<p>到了面试那一天（晚上7:30面试），还是有点慌的，毕竟是第一次面试，而且是大厂，会有面评记录（<del>已经做好被拉黑的准备了😭，但没办法，只能摁上了</del>）。</p>
<h2 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h2><p>面试官：先自我介绍一下吧</p>
<p>我：好的，balabala</p>
<p>面试官：选一个你简历上比较熟悉的项目介绍一下吧。</p>
<p>我：。。。</p>
<blockquote>
<p>我选了我的深度学习的大创项目，<del>不要问我为什么测试开发要讲深度学习的项目，因为我只有这个稍稍微微熟悉一丢丢了</del>，balabala扯了一下</p>
</blockquote>
<p>面试官：你觉得你项目中最难的点是什么？你们是怎么解决的？</p>
<p>我：。。。</p>
<blockquote>
<p>OS：完犊子了，这个没仔细想过，然后只能摁扯（<del>编</del>）了。。。</p>
</blockquote>
<p>面试官：你从这次项目中有什么收获？</p>
<p>我：。。。</p>
<p>面试官：（这里问了一些业务的问题：弹幕功能怎么设计，有哪些场景；app闪退可能是什么问题）</p>
<p>我：。。。</p>
<p>面试官：我们来做一道算法题吧</p>
<p>我：好的。。。</p>
<blockquote>
<p>一道很简单的题，leetcode上有<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">原题</a>。。。当时我也有思路，但是太紧张了，静不下心来好好思考具体怎么写，然后面试官让我说了一下思路，让我下去在实现一下（还好后来看题解中刚好有我说的那种方法，但是代码很短，我居然没写出来/(ㄒoㄒ)/~~）</p>
</blockquote>
<p>面试官：balabala（主要问了一下面试常问的<del>八股文</del>（不是），比如进程和线程的区别，tcp和udp的区别什么的）</p>
<p>我：。。。</p>
<blockquote>
<p>这些问题我也只答出来了两三个，还是我当天下午看到的几个题hhh</p>
</blockquote>
<p>面试官：你觉得你的优势有哪些？缺点有哪些？</p>
<p>我：。。。</p>
<p>面试官：你的职业规划是什么？</p>
<p>我：。。。</p>
<p>面试官：最后你有什么想问我的吗？</p>
<p>我：。。。</p>
<blockquote>
<p>我问了下可以转投暑假实习吗？（感觉我还是说的太直白了，面试官可能觉得我在耍她，我真的不是故意的/(ㄒoㄒ)/~~应该说明一下情况的。。。可惜当时没给我机会</p>
</blockquote>
<h2 id="复盘总结"><a href="#复盘总结" class="headerlink" title="复盘总结"></a>复盘总结</h2><ol>
<li>自我介绍要准备好一点，再多看看别人的建议</li>
<li>最好不要裸面，还是好好看一看别人总结的面试题。</li>
<li>面试会问你的项目，最好都仔细地回顾一下，理清一下讲述的思路（因为没有准备，我临时说的还是太乱了）。</li>
<li>好好刷算法题，写代码不要紧张，写不出来就说思路。</li>
<li>准备一些通用的问题，比如我的优缺点（是该好好想想了）、职业规划、反问面试官的问题。</li>
</ol>
<p>面完感觉肯定要被拉黑了。。。后来想想，还是安慰自己，世界那么大，干嘛非要纠结一个字节，还有很多其他公司嘛，人生是充满无限的可能的，没有所谓的最优解！</p>
<p>这次面试还有一个目的就是锤炼一下自己的脸皮2333（</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>面试总结</tag>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》笔记</title>
    <url>/2021/04/22/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文是我在大二的时候学习王爽老师的《汇编语言》所记录的笔记，里面包含我对每章的总结以及思考，最后还有一篇“读后感”总结全书。</p>
<a id="more"></a>
<h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><p>本章最重要的任务就是理解CPU与各个存储器芯片之间的数据读写是通过总线的。总线分为三种：</p>
<ol>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ol>
<p>然后，我们可以将各个存储器芯片整体看做一个逻辑存储器，不同的存储器对应着不同的地址区间。</p>
<h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><p>本章主要介绍了寄存器，寄存器主要起着存储操作码（指令）和数据的作用。</p>
<p>不同CPU的寄存器个数和结构是不一样的。</p>
<p>这一章主要讲了：</p>
<ul>
<li><p>通用寄存器如何存储数据。可以将16位通用寄存器分为两个8位寄存器。</p>
</li>
<li><p>一个字由两个字节组成</p>
</li>
<li>一些汇编指令</li>
<li>8086CPU(16位CPU)如何寻址20位的地址<ul>
<li>将20位地址拆分为 段地址x16+偏移地址，段地址和偏移地址分别由两个寄存器保存并传输给地址加法器，形成20位物理地址</li>
</ul>
</li>
<li>内存中段的概念：将连续的内存人为划分成不同的段区，一个段的起始地址就成为段地址。</li>
<li>段寄存器（以CS为例），指令指针寄存器（IP）</li>
<li>修改CS、IP的指令：jmp</li>
<li>debug的使用</li>
</ul>
<blockquote>
<ul>
<li>汇编不区分大小写</li>
<li>数据和指令没有本质区别，都是二进制数，区别在于你怎样解释它。8086CPU只认被CS:IP指向的内存单元中的内容为指令</li>
<li>将一个16位寄存器拆分成两个8位寄存器用时，低8位寄存器溢出的数据并不会存在高8位中，而是存在另一个单独的寄存器中。</li>
<li>只有位数相等的寄存器才能相互加减或移动数据</li>
<li>同一个物理地址可以由不同的段地址x16+偏移地址构成</li>
<li>CPU会根据CS:IP的地址读取内存中的指令/数据，每读取一条完整的指令，IP就会自动增加以读取下一条指令</li>
</ul>
</blockquote>
<h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h2><h3 id="字单元"><a href="#字单元" class="headerlink" title="字单元"></a>字单元</h3><p>内存中的单元是以字节为单位，存放一个字则需要两个连续的内存单元。</p>
<p>以哪一个地址为起始地址的字单元就称为几地址单元，例如：</p>
<p>一个以地址1为起始地址的字单元，它占用了1、2两个字节单元，我们称它为1地址字单元</p>
<h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><p>DS是另一个段寄存器，与CS不同的是，CS是代码段寄存器（指向要运行的指令的段地址），DS通常用来存放要访问数据的段地址。</p>
<p>8086并不支持将数据直接送入段寄存器（貌似是所有段寄存器），只能通过另一个寄存器/内存单元进行中转。</p>
<p>设置了段寄存器DS的值之后，就可以使用方括号<code>[]</code>来表示偏移地址了，这样就可以访问内存数据了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure>
<p>前面两条指令先将ds设置为1000，然后用方括号表达式将1000:0地址处的数据移动到al中。</p>
<h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>如果在mov中给出的是16位寄存器的名字，一次就能传送16位数据了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,[0]</span><br></pre></td></tr></table></figure>
<p>最后一句就是将1000:0和1000:1这两个字节单元的数据复制到bx中，bx的高8位存放1000:1的数据，低8位存放1000:0的数据，其他情况可类比。</p>
<h3 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h3><p>add、sub指令不能对段寄存器操作，即<code>add ds,ax</code>是错误的。但是可以对内存单元和通用寄存器操作。</p>
<h3 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h3><p>数据段的长度是人为规定的，同时是可以变化的，关键在你怎么看。</p>
<h3 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h3><ul>
<li>两个基本操作：入栈、出栈</li>
<li>特点LIFO（Last In First Out）</li>
</ul>
<h3 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a>3.7 CPU提供的栈机制</h3><ul>
<li>两个基本操作：入栈——push、出栈——pop</li>
<li>两个地址寄存器：SS——段寄存器、SP——偏移地址寄存器<ul>
<li>任意时刻，SS:SP指向栈顶元素</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>8086CPU的入栈和出栈操作都是以字为单位进行的，且数据的高8位总是对应高地址，低8位对应低地址</p>
</li>
<li><p>8086CPU中栈是从高地址向低地址移动的（不知道其他CPU是不是一样）,所以SP=SP-2就是指向栈顶上面的一个新的字单元</p>
</li>
<li><p>8086CPU的入栈和出栈操作都分为两步</p>
<p>Push：</p>
<ol>
<li>SP=SP-2</li>
<li>将输入送入SS:SP指向的字单元</li>
</ol>
<p>Pop：</p>
<ol>
<li>将SS:SP指向的内存单元送出到某一个寄存器</li>
<li>SP=SP+2</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="问题3-6"><a href="#问题3-6" class="headerlink" title="问题3.6"></a>问题3.6</h4><p>栈为空时，SS:SP指向的是栈底地址的SP+2，原理还是上面所说的，SS:SP是随着数据的入栈，由高地址移向低地址的。</p>
<blockquote>
<p>数据出栈之后并不会被删除，仍然存在，但是下一次有数据入栈就会把他覆盖掉，这也就解释了为什么C++中的vector，pop之后再次将下标指向原来的那个，数据仍然存在且没有变化的现象。</p>
</blockquote>
<h3 id="3-8-栈顶超界的问题"><a href="#3-8-栈顶超界的问题" class="headerlink" title="3.8 栈顶超界的问题"></a>3.8 栈顶超界的问题</h3><p>入栈和出栈都存在越界的危险，且这种情况很可能覆盖掉栈外的其他程序的代码或数据，导致一系列错误，所以这是极度危险的。</p>
<p>但是8086CPU中并没有防止栈越界的机制，所以只能靠我们编程的时候注意了。</p>
<h3 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h3><h3 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h3><ul>
<li><p>栈段也是我们编程时人为确定的，自己知道就好，计算机CPU并不会帮你设置一个栈段的标志，我们需要做的就是将SS:SP指向我们定义的栈段</p>
</li>
<li><p>8086CPU一个栈段最大容量为64KB，因为偏移地址只有16位，SP减小到0000H就会循环回到FFFFH</p>
</li>
</ul>
<h3 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h3><p>段可以分为三种：</p>
<ul>
<li>数据段——用来存放数据</li>
<li>代码段——用来存放代码</li>
<li>栈段——当做栈</li>
</ul>
<p>计算机怎么区分这三种段呢？</p>
<p>就是通过不同的段寄存器所指向的位置来区分：</p>
<ul>
<li>DS指向数据段的段地址，通过方括号<code>[]</code>来表示偏移地址</li>
<li>CS指向代码段的段地址，IP用于表示偏移地址</li>
<li>SS指向栈段的段地址，SP用于表示偏移地址</li>
</ul>
<blockquote>
<p>内存单元 寄存器中的二进制机器码本身既可以表示指令，又可以表示数据，关键在于怎么解释，而计算机就是通过上面这几个段寄存器和偏移地址寄存器来对二进制机器码进行解释的。</p>
</blockquote>
<h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><ul>
<li><strong>Debug的t命令在执行修改寄存器SS——栈的段寄存器之后，下一条指令会紧接着被执行，并不会暂停。</strong>这一点与<strong>中断机制</strong>有关，会在后半部分研究。</li>
</ul>
<h2 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h2><p>编写一个完整的汇编语言程序的流程是：</p>
<ol>
<li>编写汇编程序代码文件，即源程序</li>
<li>对源程序进行编译连接，生成可执行文件</li>
</ol>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><p>汇编语言的最简单的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	</span><br><span class="line">	mov ax,0123h</span><br><span class="line">	mov bx,0456h</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><p>assume XX:XXX</p>
</li>
<li><p>XXX segment</p>
<p>XXX ends</p>
</li>
<li><p>end</p>
</li>
</ul>
<p>都是伪指令，由编译器执行。</p>
<p>顾名思义，segment的作用就是定义一个段，例子中的段名称是codesg（这种人为定义的名称称为标号，这个标号最终会被编译、连接程序处理成一个段的段地址），assume用来指明某一个寄存器与哪一个段相关联，ends和end都是结束标志。</p>
<p>真正被翻译为机器码的是其中的汇编指令，也就是segment部分里的代码。</p>
<h3 id="编译、连接"><a href="#编译、连接" class="headerlink" title="编译、连接"></a>编译、连接</h3><p>在dos系统中，用masm程序把源程序编译，生成包含机器码的目标文件，然后用连接程序link连接目标程序，声称可执行文件。</p>
<h3 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h3><p>在DOS系统中，一个程序P2要被运行，它必须被一个正在运行的程序P1加载入内存，然后把CPU的控制权交给P2运行过程中，P1暂停运行，P2运行完毕后，P1重新获得CPU的控制权。</p>
<p>首先我们要知道在系统中是哪个程序（P1）将P2载入内存的。</p>
<ul>
<li>如果是直接在命令行执行可执行程序，那么这个P1就是命令行程序——command.com，称为命令行解释器，也是DOS系统的shell程序。</li>
<li>如果是通过其他程序执行的，例如<code>debug 1.exe</code>，那么P1就是debug程序。</li>
</ul>
<p>（那么问题来了！是哪个程序把command.com装入内存的呢？操作系统吗？那么操作系统是如何被装载入内存的呢？这个问题可以自行查找）</p>
<p>P2运行到最后的时候，怎么判断程序是否结束呢？</p>
<p>这时候就要有一个标志返回的代码，上面的例子中<code>mov ax,4c00h</code>和<code>int 21h</code>，就是用来实现返回的，我们这里不过多地讨论原理，只要知道这两句代码的意义就行。</p>
<blockquote>
<p>debug调试一个程序时最后的int 21h指令要用p命令执行</p>
</blockquote>
<h4 id="P2被加载到内存中的过程"><a href="#P2被加载到内存中的过程" class="headerlink" title="P2被加载到内存中的过程"></a>P2被加载到内存中的过程</h4><ol>
<li>找到一段偏移地址为0的地址，<code>SA:0000</code>。</li>
<li>从这个地址开始，创建一个称为程序段前缀（PSP）的数据区，大小为256字节（16进制表示就是100h），DOS会利用这个PSP来和被加载的程序进行通信。</li>
<li>从<code>SA+10h：0</code>地址处开始加载程序</li>
<li>将SA的值赋给DS寄存器（数据段寄存器），将SA+10h:0赋值给CS:IP这两个寄存器。</li>
</ol>
<h2 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h2><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>在debug程序中，我们可以直接使用：<code>mov ax,[0]</code>，将DS:0地址处的数据送入ax寄存器中，但是我们在编写源程序时，若也写成上述形式，则会被编译器解释为<code>mov ax,0</code>，若要想达到同样的目的，有几种方法可以实现：</p>
<ul>
<li>我们可以使用一个寄存器bx来保存偏移地址，然后<code>mov ax,[bx]</code>，这样编译后就没问题了，相当于是把bx当做一个变量。</li>
<li><code>mov ax,ds:[0]</code>，这样也能正确的被编译器理解。</li>
<li><code>mov ax,ds:[bx]</code>，同上。</li>
</ul>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop就是循环，基本框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	mov cx,3</span><br><span class="line">s:add ax,ax</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<p>其中s是一个标号，在汇编语言中，标号就代表了一个地址，这里的s代表的是存放<code>add ax,ax</code>这个指令的地址。</p>
<p>汇编语言中循环次数通过寄存器cx的值来控制，每次执行<code>loop s</code>这个语句的时候，会先将cx的值减一，然后判断cx是否为0，若cx的值为0，就停止循环，执行loop之后的指令，若不为零，则跳到s所标志的地址处。</p>
<h3 id="两个“新的”DEBUG命令"><a href="#两个“新的”DEBUG命令" class="headerlink" title="两个“新的”DEBUG命令"></a>两个“新的”DEBUG命令</h3><ul>
<li><p>g命令</p>
<p><code>g 偏移地址</code>，这个指令会自动执行程序指导ip指向目标的偏移地址。在我们不想单步运行，想直接快速运行到一个语句的时候就可以用这个命令。</p>
</li>
<li><p>p命令</p>
<p>在遇到loop指令的时候，可以用这个指令直接一次运行到loop结束的时候，在循环次数比较多的时候可以使用。</p>
</li>
</ul>
<h3 id="loop和-bx-联合应用"><a href="#loop和-bx-联合应用" class="headerlink" title="loop和[bx]联合应用"></a>loop和[bx]联合应用</h3><p>这里就是把bx当做一个循环里的变量，每循环一次bx会改变，以指向不同的地址，学过一些高级语言（例如c语言）的同学应该很好理解这个。</p>
<h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>除了直接<code>mov ax,[bx]</code>，这样会默认把ds的值当做段地址，我们还可以显示地写出，例如：<code>mov ax,cs:[bx]</code></p>
<p>这是把寄存器cs中的值当做段地址。</p>
<p>利用这个特性，我们可以方便的操作一些跨度比较大的地址了——通过改变段前缀的值。</p>
<h3 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h3><p>一般来说，<strong>直接向一段未知的内存空间写入内容是很危险的</strong>，因为其中可能存放着重要的系统数据或代码。</p>
<p>例如，向<code>0000:0026h</code>写入数据会引起程序崩溃和死机。</p>
<p>DOS系统中，系统和其他合法程序一般都不会使用<code>0:200~0:2ff</code>这段256字节的空间，所以，我们使用这段空间是安全的。</p>
<h3 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h3><ul>
<li><strong>cx寄存器存放的是程序的字节多少</strong>，不包含最后的<code>mov ax,4c00h</code>和<code>int 21h</code>两句。</li>
</ul>
<h2 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h2><h3 id="程序获取内存空间有两种方法："><a href="#程序获取内存空间有两种方法：" class="headerlink" title="程序获取内存空间有两种方法："></a>程序获取内存空间有两种方法：</h3><ol>
<li>在加载程序的时候为程序分配</li>
<li>在执行的过程中向系统申请</li>
</ol>
<p>这里我们只讨论第一种。</p>
<h3 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h3><p>我们可以在一个段中定义一些“常量数据”，用<code>dw</code>关键字来定义字类型数据，例如：<code>dw 0123h,0456h,0789h</code>。</p>
<p>如果我们把这句话写在只包含一个段的源程序的开头，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ...</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h</span><br><span class="line">	...</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<p>那么在该代码段的开头的三个字大小的空间，也就是我们所定义的三个字类型的数据，会被解释为该机器码对应的汇编指令，我们在debug程序中用u指令可以看到这些机器码对应一些“奇怪的汇编指令”。</p>
<p>为了使只被当做数据区域，我们需要定义一个标号，来告诉编译器真正的汇编指令开始的地址在哪，然后最后的end后要加上该标号的名字以对应，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ...</span><br><span class="line">code segment</span><br><span class="line">	dw ...</span><br><span class="line">start: ...</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>其中的start就是那个标号。编译之后，CS:IP就会指向start所指的地址了，从该处开始执行汇编指令。</p>
<h3 id="在段中使用栈"><a href="#在段中使用栈" class="headerlink" title="在段中使用栈"></a>在段中使用栈</h3><p>我们还可以在段中使用栈，方法就是用dw定义一些0数据，以达到申请内存空间的目的：<code>dw 0,0,0,0,0</code>。然后可以通过将SS:SP指向最后一个0后面的一个字的地址（如果忘了为什么是这样，请回顾第三章的栈部分）来把这段空间当做栈使用。</p>
<h3 id="使用多个栈"><a href="#使用多个栈" class="headerlink" title="使用多个栈"></a>使用多个栈</h3><p>目前我们这样还只是把数据和栈还有汇编指令都放在一个段中，这样做可能会给以后造成麻烦，结构不清晰。我们可以使用多个段来分别存储数据、代码和栈，一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw ...</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,...</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:...</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>声明多个段的方法很好理解（如上）。</p>
<p>值得注意的是，如果我们将代码部分的段不是放在第一个，例如上面是放在最后一个。那么end后就必须要加上start来指明程序的入口，如果不加的话，CS:IP就会默认指向第一个段的起始地址，这就会把数据，或者其他段的机器码解释为汇编指令从而造成错误。如果代码部分的段是放在第一个，那么最后的end后的标号可以去掉，不过还是建议写上以获得更清晰的逻辑。</p>
<h2 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h2><h3 id="and、or指令和定义字符数据"><a href="#and、or指令和定义字符数据" class="headerlink" title="and、or指令和定义字符数据"></a>and、or指令和定义字符数据</h3><p>这两个指令分别是按位与和按位或。按位与可以用来把特定的某一位变成0，按位或可以把特定的某一位变成1。这个特性可以方便地实现一些操作，比如大小写字母转换的操作，因为由观察可以得到，对应的大小写字母的二进制码只有第五位（以第零位开头）是不一样的，大写字母是0，小写字母是1，这样就可以利用按位与和按位或来实现转换了，并且不用判断原来的字母是大写还是小写。</p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ...</span><br><span class="line">datasg segment</span><br><span class="line">	db &#39;d&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">	   mov ds,ax</span><br><span class="line">	   mov bx,0</span><br><span class="line">	   mov al,[bx]</span><br><span class="line">	   and al,11011111B</span><br><span class="line">	   mov [bx],al</span><br><span class="line">	   </span><br><span class="line">	   mov ax,4c00h</span><br><span class="line">	   int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>上述的代码就是把字母d转换成大写字母，<code>db &#39;...&#39;</code>就是定义字符数据（也就是一个字节）的命令（用任意字符替代…），<code>and al,11011111B</code>就是按位与的语法，按位或是<code>or ...,...</code>。</p>
<h3 id="更灵活的寻址方式"><a href="#更灵活的寻址方式" class="headerlink" title="更灵活的寻址方式"></a>更灵活的寻址方式</h3><ol>
<li><code>[idata]</code>，用一个常量来表示偏移地址</li>
<li><code>[bx]</code>，用一个变量来表示偏移地址</li>
<li><code>[bx+idata]</code>，用一个变量和一个常量来表示偏移地址</li>
<li><code>[bx+si]</code>，用两个变量来表示偏移地址</li>
<li><code>[bx+si+idata]</code>，用两个变量加一个常量来表示偏移地址</li>
</ol>
<p>其中si是一个和bx作用差不多的寄存器，另外还有一个是di，也能如此利用。</p>
<p>第3种方法还有其他形式的写法：<code>[idata+bx]</code>、<code>idata[bx]</code>、<code>[bx].200</code>，其中第二个形式与一些高级语言（例如C语言）中的数组形式类似，idata可类比为数组名。</p>
<ul>
<li>利用变量来表示偏移+常量地址，我们可以更方便地干更多的事了，例如要处理一些“二维数组”的问题。</li>
</ul>
<p>在这一章中，作者还沁出了二重循环的问题，由于loop循环默认只能使用cx作为循环计数器，所以存在内外两层循环重复使用的问题，会造成一些逻辑bug，这时我们就要想办法了。</p>
<ol>
<li><p>可以将外部的cx值先保存在一个寄存器中，待内部循环完成后将寄存器中的值重新取出</p>
<p>这个方法可能在更复杂的编程中会遇到寄存器不够用的问题</p>
</li>
<li><p>我们还能单独申请一个内存空间用于存放cx的值</p>
<p>这样我们需要记住在哪个内存单元中存放的是哪个循环的cx值</p>
</li>
<li><p>最后我们可以申请一个栈段的空间来专门保存暂存值</p>
<p>这样就比较清晰地将数据和暂存数据分开，并且操作方便了</p>
</li>
</ol>
<p>具体例子请看书上P155-158</p>
<h2 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h2><h3 id="1-处理的数据在哪？"><a href="#1-处理的数据在哪？" class="headerlink" title="1. 处理的数据在哪？"></a>1. 处理的数据在哪？</h3><p>第一个问题的答案就是地址，前面的章节中介绍的各种寻址方式就可以用来确定数据所在的地址。</p>
<p>这里还介绍了一个新的寄存器<strong>bp</strong>，用处于bx相同，不能与bp同时使用，但可以用来替换bx，例如：<code>[bp+si+idata]</code>，<em>如果没有显性地给出段地址，包含bp的偏移地址的默认段地址就是ss。</em></p>
<p>指令在执行前，所要处理的数据可以在三个地方：1. CPU内部——即寄存器、2. 内存、3. 端口（后面介绍）</p>
<h3 id="2-要处理的数据有多长？"><a href="#2-要处理的数据有多长？" class="headerlink" title="2. 要处理的数据有多长？"></a>2. 要处理的数据有多长？</h3><p>第二个问题的答案，汇编语言中有三种方法来确定（8086CPU中能处理两种长度的数据：字节byte和字word）：</p>
<ol>
<li>通过寄存器名来确定</li>
</ol>
<p>因为汇编语言指令所处理的数据必须等长，因此只要处理的数据中出现了某一个寄存器名，那么该指令处理的数据长度就是该寄存器的长度，例如：<code>mov ax,1</code>，这里ax是一个16位寄存器，因此后面的1也是一个16位的数据；<code>mov ax,ds:[0]</code>，同样，这里处理的ds:[0]是处理ds:[0]和ds:[1]这两个字节的数据；<code>mov al,1</code>，这里al是一个8位寄存器，那么1代表的就是一个8位数。</p>
<ol>
<li>在没有寄存器的情况下，用操作符X ptr指明内存单元的长度（X代表内存长度）</li>
</ol>
<p>X ptr能定义两种长度：byte和word，例如：</p>
<p><code>mov word ptr ds:[0],1</code></p>
<p><code>mov byte ptr ds:[0],1</code></p>
<p>在上面两个就是分别指明了word和byte长度。</p>
<ol>
<li>默认</li>
</ol>
<p>有一些指令有默认的处理长度，例如<code>push [1000h]</code>就不用指明是字单元还是字节单元，因为push指令只进行字操作。</p>
<h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是除法指令。语法：<code>div reg</code>或<code>div 内存单元</code></p>
<p>div后面紧跟的是除数，被除数默认放在AX或AX和DX中，如果除数为8位，则被除数位16位，默认放在AX中，如果除数为16位，被除数为32位，默认存放在DX和AX中，DX存放高16位，AX存放低16位。</p>
<p>如果除数为8位，执行div指令后，AL的内容位为除法操作的商，AH的内容位除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
<h3 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h3><p>dd类似db和dw，dd是define double word的缩写，即定义双字型数据。</p>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup（duplicate）用来配合db、dw、dd等伪指令来实现数据的重复定义，例如：</p>
<p><code>db 3 dup (0)</code>，定义3个字节，值都为0，相当于db 0,0,0</p>
<p><code>db 3 dup (0,1,2)</code>，定义了9个字节，相当于db 0,1,2,0,1,2,0,1,2</p>
<h2 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h2><p><strong>可以修改IP，或者同时修改CS和IP的指令统称为转移指令</strong></p>
<h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>offset在汇编语言中是由便一起处理的符号，他的功能是取得标号的偏移地址，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">start: mov ax,offset start	;这里就是取得start的偏移地址，也就是0，送入ax中</span><br><span class="line">	s: mov ax,offset s		;这里是取得s的偏移地址3送入ax中</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>jmp是无条件转移指令，可以只修改ip，也能同时修改cs和ip。</p>
<p>根据jmp指令的原理来分类，可以分为两种：</p>
<ol>
<li>指令中存在的是相对位移的jmp指令</li>
<li>指令中存在的是绝对地址的jmp指令</li>
</ol>
<h4 id="1-依据位移进行转移的jmp指令"><a href="#1-依据位移进行转移的jmp指令" class="headerlink" title="1. 依据位移进行转移的jmp指令"></a>1. 依据位移进行转移的jmp指令</h4><p>这中根据相对偏移地址来转移的jmp指令有两种形式：</p>
<ol>
<li><code>jmp short 标号</code></li>
<li><code>jmp near ptr 标号</code></li>
</ol>
<p>他们之间的不同是存放相对位移的位数不同，short用8位补码来存放位移，因此所表示的范围是-128~127，</p>
<p>near是用16位补码来存放位移，所表示的范围是-32768~32767。</p>
<blockquote>
<p>值得注意的是，这里的相对偏移地址是指在CPU读取jmp指令后，(IP)=(IP)+所读取的指令长度后，(IP)与标号所表示的偏移地址的差，由于依据位移进行转移的jmp指令长度为2字节，因此上述公式一般为(IP)=(IP)+2。</p>
<p>同时，这个相对位移是在程序编译的时候算出来的</p>
</blockquote>
<h4 id="2-依据绝对地址转移的jmp指令"><a href="#2-依据绝对地址转移的jmp指令" class="headerlink" title="2. 依据绝对地址转移的jmp指令"></a>2. 依据绝对地址转移的jmp指令</h4><p>依据绝对地址进行转移的jmp指令又分为3种</p>
<ol>
<li>根据标号所在的绝对地址来修改CS:IP</li>
<li>转移地址在寄存器中的jmp指令</li>
<li>转移地址在内存中的jmp指令</li>
</ol>
<h5 id="第一种指令的格式：jmp-far-ptr-标号"><a href="#第一种指令的格式：jmp-far-ptr-标号" class="headerlink" title="第一种指令的格式：jmp far ptr 标号"></a>第一种指令的格式：<code>jmp far ptr 标号</code></h5><p>其中“far ptr”就指明了用标号所在的段地址和偏移地址修改CS:IP。转换成机器码之后，占用了5个字节，后面四个字节中，低字节所存储的是标号的偏移地址，高字节存储的段地址。</p>
<h5 id="第二种指令的格式：jmp-16位reg"><a href="#第二种指令的格式：jmp-16位reg" class="headerlink" title="第二种指令的格式：jmp 16位reg"></a>第二种指令的格式：<code>jmp 16位reg</code></h5><p>这个指令就是直接将一个16位寄存器中的值赋给IP，例如：<code>jmp ax</code>就相当于<code>mov ip,ax</code>。</p>
<p>这个指令在第二章中讲到过</p>
<h5 id="第三种指令的格式：jmp-X-ptr-内存单元地址"><a href="#第三种指令的格式：jmp-X-ptr-内存单元地址" class="headerlink" title="第三种指令的格式：jmp X ptr 内存单元地址"></a>第三种指令的格式：<code>jmp X ptr 内存单元地址</code></h5><p>这里的X可以换成word或dword，内存单元地址可以用之前所讲的任何一种形式表示。下面以实例讲解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>这些指令就是将ds:[0]的值赋给IP，达到跳转的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p><code>jmp dword ptr ds:[0]</code>就是将起始地址为ds:[0]的两个字的数值分别赋值给CS和IP，高地址的字赋给CS，低地址的赋给IP，也就是(CS)=(ds:[2])，(IP)=(ds:[0]) </p>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令是一个条件转移指令，<strong>所有的条件转移指令都是短转移，同时对应的机器码中只有位移，而不是绝对地址</strong>，也就是只有8位用来存储位移，表示范围为-128~127。</p>
<p>格式：<code>jcxz 标号</code>。</p>
<p>功能：如果(cx)==0，则执行转移，否则什么也不做，用高级语言来表示的话，如下：</p>
<p><code>if((cx)==0) jmp short 标号;</code></p>
<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>loop一般称为循环指令，但实质上也是一种条件转移指令，不过loop在判断cx的值之前要将cx的值减一，同时与jcxz的判断条件相反：如果(cx)==0，则什么也不做，否则转移至标号。</p>
<p>用高级语言来描述则是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span>((cx)!=<span class="number">0</span>)</span><br><span class="line">    jmp short 标号;</span><br></pre></td></tr></table></figure>
<h3 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h3><p>前面所讲的：</p>
<ol>
<li>jmp short 标号</li>
<li>jmp near ptr 标号</li>
<li>jcxz 标号</li>
<li>loop 标号</li>
</ol>
<p>都是根据位移进行转移的，这种根据相对地址来转移的好处在于不用关心每次运行程序时，程序具体被装在在哪段内存地址。</p>
<h3 id="转移位移超界"><a href="#转移位移超界" class="headerlink" title="转移位移超界"></a>转移位移超界</h3><p>编译器会对依据位移进行转移的指令进行检测，如果位移的范围超过了其能表示的范围，那么编译器就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	start:jmp short s</span><br><span class="line">		  db 128 dup (0)</span><br><span class="line">		s:mov ax,0ffffh</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>上面这段程序在编译的时候就会报错，因为转移的位移超过了127，如果将short改成near ptr就没有问题了。</p>
<h2 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h2><p>​        <strong>这一章所讲的内容是非常重要的，它对理解高级语言中的函数调用有着重要的意义！</strong></p>
<h3 id="1-“调用”和“返回”"><a href="#1-“调用”和“返回”" class="headerlink" title="1. “调用”和“返回”"></a>1. “调用”和“返回”</h3><p>我们首先来介绍一下调用子程序中最重要的两个指令：<strong>CALL</strong>和<strong>RET</strong>。</p>
<h4 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h4><p>call在英语中有调用的意思，所以也就不难猜到它的作用了，就是“调用”，但是它的基本原理还是转移指令。总体来说执行call指令相当于进行两步操作：</p>
<p>1）将当前的IP或CS和IP压入栈中；</p>
<p>2）转移</p>
<p>与上一章的转移指令一样，它也有多种形式：</p>
<ol>
<li><code>call 标号</code></li>
</ol>
<p>当执行这个命令的时候，CPU进行了两步操作：</p>
<p>​    1）将当前的IP压入栈中；</p>
<p>​    1）依据16位位移转移至标号的偏移地址处</p>
<p>相当于执行了以下两句指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<ol>
<li><code>call far ptr 标号</code></li>
</ol>
<p>这个指令实现的是段间转移，总体操作还是那两个步骤，下面直接用学过的汇编语句来解释更为清晰：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<ol>
<li><code>call 16位reg</code></li>
</ol>
<p>相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg	;也就是mov IP,reg</span><br></pre></td></tr></table></figure>
<ol>
<li><code>call X ptr 内存单元地址</code></li>
</ol>
<p>X可替换为word和dword。</p>
<p><code>call word ptr 内存单元地址</code>相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p><code>call dword ptr 内存单元地址</code>相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h4 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h4><p>ret可以理解为return的缩写，它有两种形式，一个是ret，一个是retf（相当于ret far？）</p>
<p>执行ret指令时，相当于进行<code>pop IP</code>，执行retf指令时，相当于先进行<code>pop IP</code> 然后<code>pop CS</code>。</p>
<h3 id="2-mul指令"><a href="#2-mul指令" class="headerlink" title="2. mul指令"></a>2. mul指令</h3><p>这里我们插入一个mul指令，为以后些更复杂的程序做准备。</p>
<p>mul是multiply的缩写，指令后面跟的参数只有1个：<code>mul reg</code>或<code>mul 内存单元</code></p>
<p>如果后面的reg或内存单元是8位的，那么另一个乘数默认存放在al中，计算的结果默认存放在ax中；如果是16位，另一个乘数默认存放在ax中，计算结果的高16位存放在dx中，低16位存放在ax中。</p>
<p>一个小例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;计算100*10</span><br><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<h3 id="3-子程序框架"><a href="#3-子程序框架" class="headerlink" title="3. 子程序框架"></a>3. 子程序框架</h3><p>学习了CALL和IP后，我们就可以知道写一个子程序并调用的框架是什么了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main: ...</span><br><span class="line">	  call sub1</span><br><span class="line">	  ...</span><br><span class="line">	  mov ax,4c00h</span><br><span class="line">	  int 21h</span><br><span class="line"></span><br><span class="line">sub1: ...</span><br><span class="line">	  call sub2</span><br><span class="line">	  ...</span><br><span class="line">	  ret</span><br><span class="line">	  </span><br><span class="line">sub2: ...</span><br><span class="line">	  ...</span><br><span class="line">	  ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h3 id="4-参数和结果的传递"><a href="#4-参数和结果的传递" class="headerlink" title="4. 参数和结果的传递"></a>4. 参数和结果的传递</h3><p>在高级语言中调用函数我们有参数和结果的传递，那么在底层是如何实现的呢？</p>
<p>1）可以通过把参数和结果存放在寄存器中来传递参数。但这种方法只适用于参数和结果比较少的情况，因为CPU内寄存器数量有限。</p>
<p>2）当需要传递的参数和结果很多的时候，我们可以将参数放到内存中，然后传输这组参数的首地址，就能通过定位内存地址的方法来处理所传参数了，这对传入参数和返回结果都适用。</p>
<h3 id="5-寄存器冲突问题"><a href="#5-寄存器冲突问题" class="headerlink" title="5. 寄存器冲突问题"></a>5. 寄存器冲突问题</h3><p>当主程序和子程序中都用到同一个寄存器（例如cx）时，那么运行时就会存在一些“意想不到”的问题。</p>
<p>之前在多重循环中解决类似问题的方法是将cx压入栈，再取出来，我们这里也能借鉴这种方法。</p>
<p>这里我们设计了一个更好的、更保险的方法：在子程序开始之前将子程序中所用到的所有寄存器的内容都保存在栈中，在子程序返回之前再恢复（这刚好应证了我前几天在《算法竞赛入门经典》中看到的函数调用栈部分）。</p>
<p>一个子程序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub1: 	push cx</span><br><span class="line">	  	push si	;假设在子程序中只要用到cx和si这两个寄存器</span><br><span class="line">	  </span><br><span class="line">change: ...</span><br><span class="line">		...</span><br><span class="line">		jcxz ok</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">	ok: pop si</span><br><span class="line">		pop cx	;注意入栈和出栈的顺序</span><br><span class="line">		ret</span><br></pre></td></tr></table></figure>
<h3 id="做实验10遇到的坑（犯的2）！！！"><a href="#做实验10遇到的坑（犯的2）！！！" class="headerlink" title="做实验10遇到的坑（犯的2）！！！"></a>做实验10遇到的坑（犯的2）！！！</h3><h4 id="1-显示字符串"><a href="#1-显示字符串" class="headerlink" title="1.显示字符串"></a>1.显示字符串</h4><p>我把初始化di（列位移）放在了change内部导致最终结果只显示最后一个字符。</p>
<h4 id="2-除法溢出"><a href="#2-除法溢出" class="headerlink" title="2.除法溢出"></a>2.除法溢出</h4><p>没大问题，理清思路就行</p>
<h4 id="3-数值显示"><a href="#3-数值显示" class="headerlink" title="3.数值显示"></a>3.数值显示</h4><p>我写这个子程序时一开始是用的8位除法，结果没有考虑到317AH（12666）除以AH（10）的结果16进制超过了2位（4F2H），导致div cl溢出，然后出现中断iret，但是我一开始并没有意识到这是中断……然后按照网上的改成了16位的除数，没有在每次除法过后清零dx，仍然是溢出的问题…..最后对比网上的代码终于发现漏了<code>mov dx,0</code>这一句……心累/(ㄒoㄒ)/~~</p>
<h2 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h2><p>标志寄存器是一种比较特殊的寄存器，它有三种作用：</p>
<ol>
<li>用来存储相关指令的某些执行结果（这些相关指令大多是运算指令，例如：add、sub、mul、div、inc、or、and等，但这些指令也不是对所有的标志位都有影响，而mov、push、pop等传送指令则对标志寄存器没有影响）</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式</li>
</ol>
<p>8086CPU中的标志寄存器是flag，flag的一些位在8086中没有用，不具有任何含义（具体见书P213页）。下面简要说明一下那些有意义的寄存器的作用：</p>
<ol>
<li><p>ZF（Zero Flag）标志——flag的第6位，零标志位。它记录相关指令执行后，其结果是否为0，如果为零，则ZF=1，否则ZF=0。</p>
</li>
<li><p>PF标志——flag的第2位，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，如果为偶数，PF=1，否则PF=0</p>
</li>
<li>SF（Sign Flag）标志——flag的第7位，符号标志位。它记录在进行<strong>有符号数</strong>的相关运算后，其结果是否为负，如果为负，SF=1，否则SF=0</li>
<li>CF（Carry Flag）标志——flag的第0位，进位标志位。它记录在进行<strong>无符号数</strong>运算的时候，运算结果的最高有效位向更高位的进位值，或从更高位的借位值</li>
<li>OF（Overflow Flag）标志——flag的第11位，溢出标志位。它记录<strong>有符号数</strong>运算的结果是否发生溢出</li>
</ol>
<blockquote>
<p>值得注意的是，3、4、5中所说的有符号数和无符号数，都是在判断的时候将所操作的二进制数据解释为有符号或无符号，二进制数本身并不代表有符号或者无符号。</p>
</blockquote>
<h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>带进位加法指令，与add指令相比，adc指令还会加上CF位上的值。例如：<code>adc ax,bx</code>就相当于<code>(ax)=(ax)+(bx)+CF</code>。</p>
<h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>带借位减法指令，与sub指令相比，sbb指令还会减去CF位上的值。例如：<code>sub ax,bx</code>相当于<code>(ax)=(ax)-(bx)-CF</code>。</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>格式：<code>cmp ax，bx</code></p>
<p>功能：比较ax，bx的大小，相当于减法指令<code>sub ax,bx</code>，但是不保存结果，只会对相关标志寄存器产生影响。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>
<p>执行后：(ax)=8，zf=0，pf=1，sf=0，cf=0，of=0。</p>
<p>cmp能对有符号数和无符号数进行判断，但是与之前所说的一样，二进制本身并没有有符号或者无符号的意义，关键是在于你如何解释。cmp在进行减法运算的时候按照的是无符号数，可以借位，解释的时候可以解释为有符号数的补码。</p>
<p>要注意的是有时候用cmp来影响sf的值来判断有符号数的大小关系可能并不会得到我们期望的结果，因为对于有符号数的计算来说，还是按照二进制的减法来进行的（CPU的加减法都是按照二进制加减法来执行的），但在最后解释为有符号数，可能会发生溢出。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ah,22h</span><br><span class="line">mov bh,0A0h</span><br><span class="line">cmp ah,bh</span><br></pre></td></tr></table></figure>
<p>我们来看一下每个步骤：</p>
<ol>
<li>把22h（00100010）送入ah中。</li>
<li>把0A0h（10100000）送入bh中。</li>
<li>计算0010,0010-1010,0000，由于前面的数字小于后面的，会向最高位的前一位假借一位，于是得到结果1000,0010。解释为无符号数的话就是130，解释为有符号数（补码）的话就是-126。</li>
</ol>
<p>而sf记录的是有符号数的符号，因此sf=1，但是如果把这个理解为有符号数的减法时，22h是34,0A0h是-96，相减得到结果是130，超过了8位无符号数的表示范围。我们的理想结果是sf=0，而结果是1，由此可以得出如果用cmp来比较有符号数时，只看sf的值是不准确的，还应结合of溢出标志位来看。如果of=1，那么逻辑上的cmp结果与实际的sf的值相反。</p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>所有的8086条件转移指令的转移位移都是[-128,127]。</p>
<p>下面列出一些其他的条件转移指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody>
</table>
</div>
<p>这些检测结果的条件转移指令与cmp配合来使用可以。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp ah,bh</span><br><span class="line">je s</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">s:add ah,ah</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑就是如果ah和bh相等，则跳转到s标号处。</p>
<h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>串传送指令：zhong</p>
<p>格式：<code>movsb</code>或<code>movsw</code></p>
<p>功能：将内存<code>ds:[si]</code>的字节/字（b是byte，w是word）传送到<code>es:[di]</code>处，然后si和di的值根据DF标志位的值递增一或递减一。</p>
<p>flag的第10位是DF，方向标志位。如果df=0，每次串传送指令操作后si、di递增，如果df=1，si、di递减。</p>
<p>用汇编语法描述movsw的功能如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov es:[di],word ptr ds:[si]	;8086并不支持这样的指令，这里只是个描述</span><br><span class="line">;如果df&#x3D;0</span><br><span class="line">add si,2</span><br><span class="line">add di,2</span><br><span class="line"></span><br><span class="line">;如果df&#x3D;1</span><br><span class="line">sub si,2</span><br><span class="line">sub di,2</span><br></pre></td></tr></table></figure>
<p>另外再介绍一个与串传送指令配合使用的指令：rep，格式：<code>rep movsb</code>，相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>
<p>只要赋给cx合适的值，就能把一段特定的字符串复制到另一段目标地址中。</p>
<p>由于df的作用，8086提供了两个指令来对df的值来进行设置：</p>
<ol>
<li>cld(clean df)：将df置0</li>
<li>std(set df)：将df置1</li>
</ol>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf是将标志寄存器的值压入栈，popf是从栈中弹出数据，送入标志寄存器中。</p>
<h2 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h2><p>每个CPU在执行完当前正在执行的指令时，都会检测CPU内部和外部是否有<strong>中断信息</strong>传来，如果有，则停止继续执行后面指令，转而去处理接收到的信息。</p>
<p>中断分为来自CPU内部和外部，分别称作内中断和外中断，本章节主要讨论内中断。</p>
<h3 id="中断的产生"><a href="#中断的产生" class="headerlink" title="中断的产生"></a>中断的产生</h3><p>CPU内部会在以下四种情况时产生的中断：</p>
<ol>
<li>除法错误，例如，div指令产生除法溢出</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ol>
<p>CPU要知道中断信息是来源于哪种情况，所以中断信息中有一个字节（<strong>中断类型码</strong>）用来标识中断信息的来源（最多可以表示256种）。上述四种中断源的中断码如下：</p>
<ol>
<li>除法错误：0</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断码类型。</li>
</ol>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>CPU收到中断信息后会跳转到相应的中断处理程序，即更改CS:IP使其指向中断处理程序的入口。那么如何根据中断类型码来判断中断相应的处理程序在哪呢？就是下面要说的<strong>中断向量表</strong></p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>中断向量就存放着中断处理程序的入口地址，中断向量表按照顺序从0号递增排序，存放在内存中的某一段。CPU只需根据中断类型码就能找到相应的中断处理程序的入口地址。</p>
<p>在8086CPU中，中断向量表存放在内存地址0处，从0000:0000到0000:03FF的1024个内存单元都存放着中断向量，并且，中断向量只能存放在这一段空间。</p>
<p>每一个中断向量对应一个中断处理程序的段地址和偏移地址，也就是4字节，因此1024个内存单元最多能存放256个中断向量，低地址存放偏移地址，高地址存放段地址。</p>
<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>8086CPU在收到中断信息之后，会发生以下过程：</p>
<ol>
<li>从中断信息中获取中断类型码</li>
<li>将标志寄存器的值压入栈</li>
<li>设置标志寄存器的第8位TF和第9位IF的值为0</li>
<li>CS的值入栈</li>
<li>IP的值入栈</li>
<li>从内存地址为中断类型码<em>4和中断类型码</em>4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
<h3 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h3><p>iret是配合中断处理程序使用的返回指令，它比ret指令多了一步popf操作：</p>
<ol>
<li>pop IP</li>
<li>pop CS</li>
<li>popf</li>
</ol>
<p>中断处理程序的内部操作如下：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回</li>
</ol>
<h3 id="自定义中断处理程序"><a href="#自定义中断处理程序" class="headerlink" title="自定义中断处理程序"></a>自定义中断处理程序</h3><p>具体的自定义中断处理程序的步骤如下：</p>
<ol>
<li>编写好中断处理程序的逻辑代码</li>
<li>将中断处理程序的代码送入一段安全的内存区域</li>
<li>设置中断向量，使之指向你存放中断处理程序的内存</li>
</ol>
<blockquote>
<p>在第1步的时候，最好将中断处理程序所要用到的数据写在中断处理程序内部的最开始，并且在第2步的时候将他们一起送入一段安全的内存区域，例如：0:200h处shenrulijie</p>
</blockquote>
<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>CPU在执行完一条指令后，会检测TF的值，<strong>如果TF=1，则会产生单步中断</strong>，引发中断过程。单步中断的中断类型码为1。</p>
<p>我们之前在debug程序中用t指令来单步运行的时候，debug会将TF设为1，使CPU工作于单步中断方式下，在CPU执行完这条指令后就引发单步中断，由之前使用t指令的现象可以猜到，单步中断对应的中断处理程序就是用来显示各个寄存器的值的。</p>
<p>为了避免执行单步中断处理程序的时候TF的值为1从而又执行单步中断处理程序的死循环，CPU会在获取中断类型码之后将TF、IF设为0。</p>
<h3 id="中断响应的特殊情况"><a href="#中断响应的特殊情况" class="headerlink" title="中断响应的特殊情况"></a>中断响应的特殊情况</h3><p>在前面的编程体验中，我们观察到在将一个寄存器的值送入ss之后，t指令现实的并不是紧跟的下一条将一个值送入sp的指令，而是再下一条指令。这是其实是发生了中断，但是CPU并没有响应，这是因为，如果在改变了ss的值之后执行中断，那么就要将标志寄存器和CS、IP的值压入栈，但是此时sp并没有改变，所以有极大的可能将这些值压入到错误的栈，然后导致一系列错误。因此，我们要让设置sp的指令紧跟设置ss的指令，CPU也不会在中途引发中断过程。</p>
<h2 id="第十三章-int指令"><a href="#第十三章-int指令" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h2><p>在前一章提到过，int指令会引发中断，我们之前所写的所有程序最后都有两句：<code>mov ax,4c00h</code>和<code>int 21h</code>。</p>
<p>我们在这一章就可以解释了这两条指令所做的操作了。</p>
<p>首先int指令的格式就是<code>int n</code>，n是一个立即数，其含义是中断类型码，执行完这条指令后CPU就会执行对应中断类型码的中断处理程序，例如，如果执行了<code>int 0</code>这条指令，即使没有出现除法错误的情况，CPU也会去执行处理除法错误的中断处理程序。</p>
<p>由此可见，int指令和call指令的功能相似，都是调用一段程序。</p>
<p>一般而言，系统会将一些有特定功能的子程序以中断处理程序的形式供给应用程序调用，我们可以在编程时使用int指令直接调用，我们也能自己编写中断处理程序供给别人使用。以后，我们将中断处理程序简称为<strong>中断例程</strong>。</p>
<p>那么int指令前面的那一条指令的作用是什么？</p>
<p>这是因为在一段中断例程中包含多个具有不同功能的子程序，如何选择执行哪个子程序？就要通过设置各种寄存器的值来传递参数，例如21h号中断例程，通过设置ah的值来选择子程序，4ch号子程序的功能室程序返回，然后通过al来设置程序返回值，因此<code>mov ax,4c00h</code>就是调用4c号子程序来使程序返回，并设置返回值为0。树上的13.6和13.7小结讲解了几个调用BIOS和DOS提供的中断例程的例子，具体请君自行看书～</p>
<h3 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h3><p>步骤与前一章自定义中断处理程序的步骤一致。不过在设置中断向量表的时候要注意将中断向量设置到没有被占用的内存区中（书上例子是保存在7ch表项）。</p>
<h3 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h3><p>这一小节中，书上自定义了一个与loop具有相同功能的中断例程，存放在7ch处。</p>
<p>有几个关键点：</p>
<ol>
<li><p>如何获取要转移的位移？</p>
<p>书上的解决方案是在int指令后加一个结束标号，然后用起始标号减去结束标号，差值存放在bx中，传递给中断例程。</p>
</li>
<li><p>如何设置CS:IP？</p>
<p>如果直接在子程序中间设置CS:IP，那么在iret返回主程序之后，CS:IP的值会被从栈中弹出的值覆盖掉，于是我们可以利用CPU执行中断例程前的操作和iret指令的特点来设置：直接修改栈中的值，然后iret返回操作时直接将CS:IP的值设置为我们想要的值。</p>
</li>
</ol>
<h3 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h3><p>BIOS（Basic Input Output System）存放于系统板ROM，主要有以下内容：</p>
<ol>
<li>硬件系统的检测和初始化程序</li>
<li>外部中断（15章讲解）和内部中断的中断例程</li>
<li>用于对硬件设备进行I/O操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ol>
<p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。</p>
<p>我们可以用int指令直接调用BIOS和DOS提供的中断例程。</p>
<blockquote>
<p>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>
</blockquote>
<h3 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h3><ol>
<li>开机后，CPU一家店，初始化（CS）=0FFFFH，（IP）=0，自动从FFFF：0单元开始执行程序。FFFF：0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</li>
<li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为他们是固化到ROM中的程序，一直在内存中存在。</li>
<li>硬件系统检测和初始化完成后，调用<code>int 19h</code>进行操作系统的<strong>引导</strong>。从此将计算机交由操作系统控制。</li>
<li>DOS启动后，除完成其他工作外，还将他所提供的中断例程装入内存，并建立相应的中断向量。</li>
</ol>
<h4 id="检测点13-2"><a href="#检测点13-2" class="headerlink" title="检测点13.2"></a>检测点13.2</h4><blockquote>
<ol>
<li>我们不能改变FFFF：0处的指令，应为这些是固化在ROM中的</li>
<li>int 19h中断例程不能由DOS提供，因为DOS是由int 19h例程引导之后才启动的</li>
</ol>
</blockquote>
<h2 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h2><p>在PC机中，和CPU通过总线相连的芯片除了各种存储器外，还有以下3中芯片。</p>
<ol>
<li>各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；</li>
<li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li>
<li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li>
</ol>
<p>这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，他们在物理上可能处于不同的芯片中，但是他们可以在以下两点上相同。</p>
<ol>
<li>都和CPU的总线相连，当然这种连接是通过他们所在的芯片进行的。</li>
<li>CPU对他们进行读或写的时候都通过控制线向他们所在的芯片发出端口读写命令。</li>
</ol>
<p>可见，从CPU的角度，将这些寄存器都当做端口，对他们进行统一编址，从而建立了一个统一的端口地址空间。每个端口在地址空间中都有一个地址。</p>
<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。对端口的读写不能通过mov、push、pop等命令，而只能使用<strong>int</strong>和<strong>out</strong>，分别用于从端口读取数据和往端口写入数据。例子：<code>in al,60h</code>、<code>out 20h,al</code>。注意：<strong>在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax</strong>。</p>
<p>对0~255以内的端口进行读写时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in al,20h	;从20h端口读入一个字节</span><br><span class="line">out 20h,al	;往20h端口写入一个字节</span><br></pre></td></tr></table></figure>
<p>对256~65535的端口进行读写时，端口号放在dx中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对端口地址的个人理解：8086的端口地址与内存地址在数字上可以重复，因此对端口的操作局需要in和out两个专门的指令来指明我们是在读写端口，而不是在读写内存。还有另一种端口编址就是与内存地址不重复，这样就可以不需要单独的指令了。</p>
<p>以上两种编址方式分别为：独立编址和统一编址，请君自行搜索了解。</p>
</blockquote>
<h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>该芯片的一个特点是：</p>
<p>该芯片内部有2个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM。</p>
<p>其中70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out 70h,2	;将2送入端口70h</span><br><span class="line">in al,71h	;从端口71h读出2号单元的内容</span><br></pre></td></tr></table></figure>
<p>其余特点请见书～</p>
<h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><p>shl和shr指令是逻辑位移指令。</p>
<p>shl是逻辑左移，它的功能为：</p>
<ol>
<li>将一个寄存器或内存单元中的数据向左移位；</li>
<li>将最后移除的一位写入CF中；</li>
<li>最低位用0补充。</li>
</ol>
<p>shr是逻辑右移，与shl的功能仅仅是方向不同，高位用0补充。</p>
<blockquote>
<p>有二进制基础的同学应该知道左移和右移的数学意义就是乘以2和除以2</p>
</blockquote>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1	;将al中的数据左移一位</span><br><span class="line"></span><br><span class="line">mov cl,3	;如果移动位数大于1，必须将移动位数放在cl中</span><br><span class="line">shr al,cl</span><br></pre></td></tr></table></figure>
<h3 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h3><p>CMOS RAM中以BCD码的形式存放着当前的时间。</p>
<h2 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h2><p>之前已经说来自于CPU外部的中断称为外中断，外中断的来源就是CPU外部的芯片（各种外设）。</p>
<h3 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h3><p>CPU对外设的读写、控制是通过接口芯片的端口来连接的：读写数据以及控制命令都是CPU发送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施读写、控制。</p>
<h3 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h3><p>外部中断信息是由外部相关芯片发送到CPU的。</p>
<p>外中断源一共有以下两类：</p>
<ol>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ol>
<h4 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h4><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。如果IF=1，则CPU会响应中断，如果IF=0则不会响应。</p>
<p>之前我们学过，CPU响应中断之前会将IF、TF的值设为0，这正是为了在中断例程中屏蔽其他可屏蔽中断。</p>
<p>如果我们在自己编写的中断例程中可以处理可屏蔽中断，CPU也提供了相关指令来设置IF的值：</p>
<ol>
<li>sti，设置IF=1；</li>
<li>cli，设置IF=0。</li>
</ol>
<h4 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h4><p>如字面意思，不可屏蔽中断就是CPU必须响应的中断。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以在终端过程中，不需要取中断类型码。 </p>
<p>不可屏蔽的中断过程：</p>
<ol>
<li>标志寄存器入栈，IF=0，TF=0；</li>
<li>CS、IP入栈</li>
<li>(IP)=8，(CS)=(0AH)。</li>
</ol>
<blockquote>
<p>几乎所有由外设引发的外中断，都是可屏蔽中断。</p>
<p>不可屏蔽中断是在系统中有必须处理的紧急情况是用来通知CPU的终端信息。</p>
</blockquote>
<h3 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h3><h4 id="1-键盘输入"><a href="#1-键盘输入" class="headerlink" title="1.键盘输入"></a>1.键盘输入</h4><p>键盘上每按下一个键，键盘上的芯片就会产生一个扫描码（键的编码），然后被送入主板上相关接口芯片的寄存器中，该寄存器的端口地址为60h（8086机）。</p>
<p>松开按键的时候，也会产生一个扫描码，用来说明松开的键在键盘上的位置。松开键时产生的扫描码也被送入60h端口中。也会引发中断。</p>
<p>一般讲按下键产生的扫描码成为通码，松开键产生的扫描码成为断码。它们有如下关系：断码=通码+80h。</p>
<h4 id="2-引发9号中断"><a href="#2-引发9号中断" class="headerlink" title="2.引发9号中断"></a>2.引发9号中断</h4><p>当扫描码到达60h端口时，相关芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</p>
<h4 id="3-执行int-9中断例程"><a href="#3-执行int-9中断例程" class="headerlink" title="3.执行int 9中断例程"></a>3.执行int 9中断例程</h4><ol>
<li>读出60h中的扫描码；</li>
<li>如果是字符键的扫描码，将该扫描码和它对应的字符码（ASCII码）送入内存中BIOS键盘缓冲区；如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元。</li>
<li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li>
</ol>
<blockquote>
<p>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入。</p>
</blockquote>
<h2 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h2><h3 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h3><p>我们之前使用的标号后面都带有一个冒号，这种标号代表着内存单元的地址（段地址和偏移地址），而这里我们在介绍一种新的标号——不带后面的冒号。</p>
<p>例：<code>a db 0,1,2,3,4,5,6,7,8,9</code>。其中a就是标号。</p>
<p>这种标号不但代表内存单元的地址，还表示了内存单元的长度——是字节单元还是字单元还是双字单元。若后面定义的是db，则是字节单元，若是dw则是字单元，dd类比。</p>
<p>既然这种标号还表示内存单元长度，那么在mov等指令中就不必指出内存单元长度了，可以直接<code>mov a,2</code>，就相当于<code>mov byte ptr cs:0,2</code>，这里的cs:0只是用来表示a所代指的地址。</p>
<p>同样，如果mov两个操作数的长度不匹配，则在编译时会报错。</p>
<h3 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h3><p>注意：我们之前常用的带有冒号的标号只能在代码段中使用，也就是assume指明关联cs的段。</p>
<p>但是我们刚刚讲的不带冒号的标号可以用在其他段中，特别是在数据段中，能发挥很大的作用。</p>
<p>如果想在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。否则在编译的时候，无法确定标号的段地址在哪一个寄存器。使用了assume伪指令之后，我们还要让该段寄存器存放与之关联的段的地址。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	a db 1,2,3,4,5,6,7,8</span><br><span class="line">	b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov si,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s:	mov al,a[si]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add b,ax</span><br><span class="line">	inc si</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>上面这段程序的功能是将a标号处的8个数据累加，存储在b标号处的字中。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">表示下一条地址从偏移地址<span class="number">204</span>H开始，和安装后的偏移地址相同，若没有org <span class="number">204</span>H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别</span><br><span class="line">;名称：int_7CH</span><br><span class="line">;功能：如下功能子程序：清屏，设置前景色，设置背景色和向上滚动一行，功能号为<span class="number">0</span>~<span class="number">3</span>表示下一条地址从偏移地址<span class="number">204</span>H开始，和安装后的偏移地址相同，若没有org <span class="number">204</span>H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别</span><br><span class="line">;名称：int_7CH</span><br><span class="line">;功能：如下功能子程序：清屏，设置前景色，设置背景色和向上滚动一行，功能号为<span class="number">0</span>~<span class="number">3</span>表示下一条地址从偏移地址<span class="number">204</span>H开始，和安装后的偏移地址相同，若没有org <span class="number">204</span>H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别</span><br><span class="line">;名称：int_7CH</span><br><span class="line">;功能：如下功能子程序：清屏，设置前景色，设置背景色和向上滚动一行，功能号为<span class="number">0</span>~<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>再将ds与data关联，并且设置ds后，编译器会将指令<code>mov al,a[si]</code>编译为<code>mov al,[si+0]</code>，<code>add b,ax</code>编译为<code>add [8],ax</code>。</p>
<p>如果把标号当做数据来定义，那么编译器会将标号所表示的地址当做数据的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	a db 1,2,3,4,5,6,7,8,9</span><br><span class="line">	b dw 0</span><br><span class="line">	c dw a,b	;若定义为dw类型，则储存的是a，b所在的偏移地址</span><br><span class="line">	d dd a,b	;若定义为dd类型，则存储的是a，b的偏移地址和段地址——低字存放偏移地址，高字存放段地址</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里再补充一个指令seg，取段地址</p>
<p><code>c dw seg a</code>就是取a标号的段地址存放在c处。</p>
</blockquote>
<h3 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>直接定址表就相当于高级语言中的数组，也能理解为<strong>一一映射</strong>的hashmap。</p>
<p>直接定址表是通过上一节所讲的不带冒号的标号来实现的。例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table db &#39;01234567890ABCDEF&#39;	;这里定义了一个字符表</span><br></pre></td></tr></table></figure>
<p>通过这个表，我们能很容易的把16进制的数字转换成相应的能显示的字符。例：<code>mov ah,table[10]</code>就是将字符A移入ah中。</p>
<p>可以想象，通过构造直接定址表，我们能把一些有限情况、且已知答案的问题的答案存放在直接定址表中，根据输入直接输出对应的答案，这种程序运行的速度是非常快的，我们所做的牺牲就是一些存储单元。</p>
<p>我们还能将其他标号的地址构成一个直接定址表，通过访问这个直接定址表来获取其他标号的地址，从而访问其他标号。使用这种方法的程序比不使用直接定址表的程序要简洁、优美。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">表示下一条地址从偏移地址<span class="number">204</span>H开始，和安装后的偏移地址相同，若没有org <span class="number">204</span>H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别</span><br><span class="line">;名称：int_7CH</span><br><span class="line">;功能：如下功能子程序：清屏，设置前景色，设置背景色和向上滚动一行，功能号为<span class="number">0</span>~<span class="number">3</span>表示下一条地址从偏移地址<span class="number">204</span>H开始，和安装后的偏移地址相同，若没有org <span class="number">204</span>H，中断例程安装后，标号代表的地址改变了，和之前编译器编译的有所区别</span><br><span class="line">;名称：int_7CH</span><br><span class="line">;功能：如下功能子程序：清屏，设置前景色，设置背景色和向上滚动一行，功能号为<span class="number">0</span>~<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a>程序入口地址的直接定址表</h3><p>这一节就是用到了上面提到的将其他标号所代表的子程序的地址构成一个直接定址表，并通过这个直接定址表来访问子程序。</p>
<p>直接定址表可以实现利用功能号来访问子程序，使程序结构清晰，便于扩充。</p>
<h3 id="实验16遇到的坑及感悟！！！"><a href="#实验16遇到的坑及感悟！！！" class="headerlink" title="实验16遇到的坑及感悟！！！"></a>实验16遇到的坑及感悟！！！</h3><p>遇到的坑：</p>
<ul>
<li>最大并且唯一的坑就是setscreen程序中<code>call word ptr table[bx]</code>这条指令，由于table标号在编译阶段就被转化为偏移地址，因此在安装至0:204h之后，table仍然代表的是原来的偏移地址，但是我们在触发7ch号中断后的段地址是0，因此偏移地址肯定不是原来的偏移地址了，这就导致call指令会调到其他的子程序去。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>在安装程序中的setscreeen中断例程前加一条<code>org 204h</code>指令。这个指令是在下一条指令之前补充一定数量的0机器码（用来“凑数”）来使得偏移地址达到org后面所加的数值。这样编译好的table所代表的偏移地址就是安装之后的偏移地址了。</li>
</ul>
<blockquote>
<p>经过这一次实验的“历练”，我印象最深刻的就是标号所代表的偏移地址是在编译阶段就被转化为具体的数的，而不是在运行阶段。。。。。。虽然这一点在本书的前面某个章节提到过。。。。。。但是我当时没有特别重视/(ㄒoㄒ)/~~</p>
</blockquote>
<h2 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h2><h3 id="int9中断例程对键盘输入的处理"><a href="#int9中断例程对键盘输入的处理" class="headerlink" title="int9中断例程对键盘输入的处理"></a>int9中断例程对键盘输入的处理</h3><p>在第十五章中，我们已经讲解过int9中断例程，这里再简单介绍一下。</p>
<p>键盘输入将引发9号中断，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。8086的键盘缓冲区有16个字单元，可以存储15个案件的扫描码和对应的ASCII码。</p>
<p>键盘缓冲区是用<strong>环形队列结构管理的内存区</strong>。</p>
<h3 id="使用int16h中断例程读取键盘缓冲区"><a href="#使用int16h中断例程读取键盘缓冲区" class="headerlink" title="使用int16h中断例程读取键盘缓冲区"></a>使用int16h中断例程读取键盘缓冲区</h3><p>int16h中断例程中包含的最重要的功能是从键盘缓冲区读取一个键盘输入，该功能的编号为0。下面的指令从键盘缓冲区读取一个键盘输入，并且将其从缓冲区删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br></pre></td></tr></table></figure>
<p>执行结果是：(ah)=扫描码，(al)=ASCII码。</p>
<p>因为键盘缓冲区是通过环形队列来管理的内存区，所以读取键盘缓冲区的数据的顺序与输入的顺序相同。</p>
<p>int16h中断例程的0号功能，会进行如下的工作：</p>
<ol>
<li>检测键盘缓冲区是否有数据；</li>
<li>没有则继续做第1步；</li>
<li>读取缓冲区第一个子单元中的键盘输入；</li>
<li>将读取的扫描码送入ah，ASCII码送入al；</li>
<li>将已读取的键盘输入从缓冲区中删除。</li>
</ol>
<h3 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h3><p>思路：通过利用int9和int16h中断来实现获取输入的字符。同时自己构造一个字符栈用来存储输入的字符，然后“转发’’到显示缓存区去。</p>
<h3 id="用int13h中断例程对磁盘进行读写"><a href="#用int13h中断例程对磁盘进行读写" class="headerlink" title="用int13h中断例程对磁盘进行读写"></a>用int13h中断例程对磁盘进行读写</h3><p>BIOS提供了int13h中断例程对磁盘进行读写，由于这部分不是重点，具体的参数和用法请自行看书。</p>
<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>个人觉得我们现在还是应该要学一学汇编语言的，为的不是以后用汇编来编写真正实用的程序，而是为了理解我们使用高级语言的一些特性背后的东西，理解一些重要的概念、思想和原理。</p>
<p>例如：</p>
<ol>
<li>在本书的第一章，最重要的概念就是一台PC机中，各个芯片与CPU是通过总线相连的。我们可以把各个存储器芯片整体看成一个逻辑存储器，不同部分的地址，对应着不同的芯片。</li>
<li>第二章最重要的就是理解“段”、“段地址”和“偏移地址”的概念和思想了。这种思想可以让我们在寄存器位数不足的情况下能访问更多的地址。同时理解CPU读取、执行指令的过程也很重要。</li>
<li>第三章又介绍了一个非常重要的概念——栈。栈在之后的学习中起着非常重要的作用，例如：它能帮助暂时保存寄存器中的数值。同时，联想到C++语言中的栈，不难理解为什么栈存在越界的问题了。</li>
<li>第四章至第八章主要讲的是汇编语言本身的一些语法以及技巧，在以后的编程过程中，我们也能从中获益，毕竟所有的程序都会被编译成汇编语言进而转化为机器语言的。其中第七章的定位内存地址的方法与高级语言中的数组之类的数据结构有相似之处。</li>
<li>第九章与第十章所讲的，个人认为是对我们理解高级语言中的一些东西最有意义的了。例如，第九章的转移指令原理让我们理解了循环、选择语句的原理；第十章的CALL和RET就对应着高级语言中的函数调用了，这里介绍的解决函数调用寄存器冲突的方法与C语言中的函数调用栈相一致（这也说明了栈的重要性。同时似乎也能部分解释高级语言中的局部变量和全局变量？）。</li>
<li>第十一章到第最后一章，个人认为是比较偏向硬件的。其中对于中断和端口的理解可能会在以后的编程中给我们启示。</li>
</ol>
<p>总的来说，看完这本书的收获还是蛮多的，感觉在以后的高级语言编程中会给我一些帮助。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《汇编语言》</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>objdump反汇编对于小白的一个坑</title>
    <url>/2021/04/21/objdump%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8E%E5%B0%8F%E7%99%BD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<p>作为一名小白，在WSL中做一个操作系统小实验的时候，需要查看编译后代码的汇编实现，于是使用<code>objdump</code>工具直接反汇编。发现跟以前学过的汇编有些不一样（学过8086汇编），上网查询Intel x86汇编的格式（因为我的机器是Intel的CPU），发现得到的汇编格式于Intel标准的汇编格式有些不一样，如下（部分）：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000001203 &lt;do_sum&gt;:</span><br><span class="line">    1203:       f3 0f 1e fa             endbr64</span><br><span class="line">    1207:       48 8b 15 0a 2e 00 00    mov    0x2e0a(%rip),%rdx        # 4018 &lt;sum&gt;</span><br><span class="line">    120e:       b8 00 e1 f5 05          mov    $0x5f5e100,%eax</span><br><span class="line">    1213:       83 e8 01                sub    $0x1,%eax</span><br><span class="line">    1216:       75 fb                   jne    1213 &lt;do_sum+0x10&gt;</span><br><span class="line">    1218:       48 8d 82 00 e1 f5 05    lea    0x5f5e100(%rdx),%rax</span><br><span class="line">    121f:       48 89 05 f2 2d 00 00    mov    %rax,0x2df2(%rip)        # 4018 &lt;sum&gt;</span><br><span class="line">    1226:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>主要是对于第一个操作数和第二个操作数顺序的疑惑，以一个<code>mov</code>命令为例：<code>mov A, B</code>。</p>
<blockquote>
<p>这里的A、B只是表示一个操作数的符号，用于代替一个寄存器or一个地址</p>
</blockquote>
<p>在Intel标准中，<code>mov</code>的第一个操作数A是目的操作数，第二个操作数B是源操作数，即这条汇编的含义是，把B的值赋值给A。</p>
<p>如果按照这种标准，我上面反汇编得到的第二条mov指令（<code>mov $0x5f5e100,%eax</code>）就是把<code>eax</code>寄存器的值赋值给<code>$0x5f5e100</code>，但是这个16进制的值是我定义的一个循环次数n（100,000,000，也就是一亿），于是感觉有问题。</p>
<p>经过大佬的指点，在Windows中使用IDA软件对这个程序进行反汇编，得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000001203                 public do_sum</span><br><span class="line">.text:0000000000001203 do_sum          proc near               ; DATA XREF: main+8↓o</span><br><span class="line">.text:0000000000001203                                         ; main+14↓o</span><br><span class="line">.text:0000000000001203 ; __unwind &#123;</span><br><span class="line">.text:0000000000001203                 endbr64</span><br><span class="line">.text:0000000000001207                 mov     rdx, cs:sum</span><br><span class="line">.text:000000000000120E                 mov     eax, 5F5E100h</span><br><span class="line">.text:0000000000001213</span><br><span class="line">.text:0000000000001213 loc_1213:                               ; CODE XREF: do_sum+13↓j</span><br><span class="line">.text:0000000000001213                 sub     eax, 1</span><br><span class="line">.text:0000000000001216                 jnz     short loc_1213</span><br><span class="line">.text:0000000000001218                 lea     rax, [rdx+5F5E100h]</span><br><span class="line">.text:000000000000121F                 mov     cs:sum, rax</span><br><span class="line">.text:0000000000001226                 retn</span><br><span class="line">.text:0000000000001226 ; &#125; &#x2F;&#x2F; starts at 1203</span><br><span class="line">.text:0000000000001226 do_sum          endp</span><br></pre></td></tr></table></figure>
<p>可以很明显的观察到，与objdump的反汇编结果的样子有较大区别，对比第二条mov指令，发现两个操作数的顺序反了过来，对头！（这熟悉的味道，这才是Intel的汇编嘛）这种的汇编按照Intel的解释也很合理（将循环次数赋值给eax，然后不断减一判断循环）。</p>
<p>于是发现问题所在，可以确定objdump所得到的汇编肯定不是Intel格式的，经过进一步的搜索，发现objdump默认的汇编格式是<strong>AT&amp;T</strong>。并且知道了objdump可以通过<code>-M</code>参数来修改反汇编的格式（具体请<code>man objdump</code>），于是使用<code>objudmp -d test -M intel | less</code>（其中test是我需要反汇编的文件名）命令得到如下汇编结果（部分）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000001203 &lt;do_sum&gt;:</span><br><span class="line">    1203:       f3 0f 1e fa             endbr64</span><br><span class="line">    1207:       48 8b 15 0a 2e 00 00    mov    rdx,QWORD PTR [rip+0x2e0a]        # 4018 &lt;sum&gt;</span><br><span class="line">    120e:       b8 00 e1 f5 05          mov    eax,0x5f5e100</span><br><span class="line">    1213:       83 e8 01                sub    eax,0x1</span><br><span class="line">    1216:       75 fb                   jne    1213 &lt;do_sum+0x10&gt;</span><br><span class="line">    1218:       48 8d 82 00 e1 f5 05    lea    rax,[rdx+0x5f5e100]</span><br><span class="line">    121f:       48 89 05 f2 2d 00 00    mov    QWORD PTR [rip+0x2df2],rax        # 4018 &lt;sum&gt;</span><br><span class="line">    1226:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>基本与IDA的结果一致（差异可忽略）。</p>
<p>总结一下本次经历学到的一些知识：</p>
<p><strong>x86架构汇编指令一般有两种格式</strong>：<strong>Intel汇编和AT&amp;T汇编</strong>，DOS、Windows使用Intel汇编，而Unix、Linux、MacOS使用AT&amp;T汇编。</p>
<p>下面简单列出几个Intel和AT&amp;T汇编格式的区别：</p>
<ol>
<li>第一当然是两个操作数的顺序啦：Intel的第一个操作数是目标操作数，第二个操作数是源操作数；AT&amp;T的第一个操作数是源操作数，第二个操作数是目标操作数。</li>
<li>寄存器的表示：Intel的寄存器直接写寄存器的名字就行（eax）；AT&amp;T的寄存器需要在前面加一个百分号%修饰（%eax）。</li>
<li>立即数表示：Intel的立即数前不用加任何标志（1）；AT&amp;T的立即数前需要加<code>$</code>符号修饰（$1）。</li>
<li><p>括号的使用：Intel中寻址时用的括号是中括号<code>[]</code>；AT&amp;T中使用的是小括号<code>()</code>。</p>
</li>
<li><p>……      </p>
</li>
</ol>
]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>逆向/反汇编</category>
      </categories>
      <tags>
        <tag>objdump</tag>
        <tag>汇编语言</tag>
        <tag>反汇编</tag>
        <tag>汇编格式</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》 Ch7 动态链接（上）</title>
    <url>/2021/04/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h3 id="7-1-为什么要动态链接"><a href="#7-1-为什么要动态链接" class="headerlink" title="7.1 为什么要动态链接"></a>7.1 为什么要动态链接</h3><p>首先，要明确一个问题：<strong>为什么要用动态链接？静态链接这么简单好用，不香吗？</strong></p>
<p>主要出于以下两个原因：</p>
<ul>
<li>静态链接会造成硬盘与内存的空间浪费</li>
<li>静态链接程序的更新麻烦</li>
</ul>
<a id="more"></a>
<p>第一个问题：</p>
<p>因为，静态链接是在链接的时候就把程序依赖的所有目标文件都合并到最终的可执行程序里，而一个程序往往会用到许多公共的目标文件（库），例如C语言标准库（<code>stdio.h</code>、<code>stdlib.h</code>等）。如果计算机中的每个程序都包含C语言标准库的目标文件，那么以当今计算机中程序的数量来看，你的硬盘空间是大概率不够的。同时，静态链接的程序是被整体加载到内存中的，因此，当多个程序都被加载到内存中，它们所包含的标准库部分也会被重复加载许多次，这就造成了内存空间的极大浪费，以今计算机操作系统中运行的程序数量来看，你有限的内存大小也是顶不住的。</p>
<p><img src="/2021/04/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/7.1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%97%B6%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt="7.1-静态链接时文件在内存中的副本" style="zoom: 33%;"></p>
<center>图7.1 静态链接时文件在内存中的副本</center>

<p>第二个问题：</p>
<p>如果一个程序（假设是<code>Program1</code>）使用的一个第三方公共目标文件（假设是<code>Lib.o</code>）进行了更新，那么<code>Program1</code>需要进行重新链接，再发布给用户，用户需要重新下载整个程序，如果这个程序用了100个模块（目标文件、库），每个假设是1MB，整个程序100MB，那么即使每次只改动了某个模块的一个地方，那么也要重新链接整个程序，用户也要重新下载，对用户非常不友好。</p>
<p><img src="/2021/04/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/7.2-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%97%B6%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt="7.2-动态链接时文件在内存中的副本" style="zoom: 33%;"></p>
<center>图7.2 动态链接时文件在内存中的副本</center>



<p><strong>动态链接</strong></p>
<p>动态链接的原理就是把程序的模块分割开来，使之成为一个个相互独立的文件，<strong>并一直保持这种状态，直到程序被加载到内存中运行</strong>。当点击该程序运行时，该程序所依赖的所有模块（文件）都被加载到内存，然后由动态链接器进行链接操作，链接操作基本与静态链接一致。</p>
<p>这种把链接过程推迟到运行时进行的思想就是动态链接的基本原理。</p>
<p>第一，动态链接所加载的部分模块（公共模块）是可以被多个程序共用的，这就大大减少了内存浪费；第二，倘若程序中的某个模块更新了，理论上我们只需要覆盖掉老版本的模块目标文件就行（不过实际还要考虑得多一点，比如新旧接口兼容问题）。</p>
<p><strong>程序可扩展性和兼容性</strong></p>
<p>动态链接还带来一个特点，就是程序可以在运行时动态地选择加载各种程序模块，这种机制可以被用来制作<strong>插件（Plug-in）</strong>。</p>
<blockquote>
<p>比如某个公司开发完成了某个产品，它按照一定的规则制定好程序的接口，其他公司或开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种由第三方开发的模块，在程序运行时动态地链接，实现程序功能的扩展。</p>
<p>动态连接还加强了程序在不同平台/机器的兼容性，比如一个程序在不同平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台依赖的差异性。</p>
<p>有一句话说得好，“在计算机领域，没有什么是不能通过添加一层中间层解决的”（狗头</p>
<p>比如操作系统A和操作系统B对于<code>printf()</code>的实现机制不同，如果我们的程序是静态链接的，那么程序就需要在A、B两个平台分别编译链接；如果用的是动态链接，那么程序只需要有一个版本，就可以在两个操作系统上运行，动态地选择<code>printf()</code>的实现版本（不过这仅仅是理想情况下，实际还要考虑其他东西，例如接口版本）。</p>
</blockquote>
<p>动态链接也带来了一些问题，最常见的一个问题是，当程序所依赖的某个模块更新了，更新前后的接口并不兼容，那么就导致主程序不能运行。于是我们需要一种管理机制来管理动态链接库的版本。</p>
<p><strong>动态连接的基本实现</strong></p>
<p>动态链接的基本原理前面已经说过了，现在考虑一个事，我们能直接将静态链接用到的目标文件当作动态链接所用的模块文件吗？答案是不行。实际的动态链接文件与目标文件有一些区别（大体上一致），后面会介绍。</p>
<p>动态链接需要操作系统的支持，Linux下的动态链接文件称作<strong>动态共享对象（Dynamic Shared Object）</strong>，简称共享对象，一般以<code>.so</code>为后缀；Windows下的动态链接文件称作<strong>动态链接库（Dynamic Linking Library）</strong>，后缀一般为<code>.dll</code>。</p>
<h3 id="7-2-简单的动态链接例子"><a href="#7-2-简单的动态链接例子" class="headerlink" title="7.2 简单的动态链接例子"></a>7.2 简单的动态链接例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Program1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        foobar(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Program2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        foobar(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lib.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lib.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Printing from Lib.so %d\n"</span>, i);</span><br><span class="line">        sleep(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译链接过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so Lib.c</span><br><span class="line">gcc -o Program1 Program1.c ./Lib.so</span><br><span class="line">gcc -o Program2 Program2.c ./Lib.so</span><br></pre></td></tr></table></figure>
<p>注意产生Lib.so的两个关键参数：<code>-fPIC</code> 和<code>-shared</code> 。<code>-shared</code>是必须的参数，<code>-fPIC</code>则是下文所要介绍的PIC技术。</p>
<p><img src="/2021/04/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/7.3-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="7.3-动态连接过程" style="zoom:50%;"></p>
<center> 图7.3 动态连接过程</center>

<p>为什么在生成可执行文件的时候仍要Lib.so“参与链接工作”呢？其实这里的链接并不是真正的链接，而是为了让Program1知道其中引用的<code>foobar</code> 函数是一个动态链接的符号，从而不进行重定位，而是把这个过程留到装载时再进行。同时，如果Lib.so“不参与链接”，那么生成可执行文件的过程可能会产生找不到符号定义的问题。</p>
<p>然后运行其中一个可执行文件（以Program1为例），并查看它的虚拟地址空间映射，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">doa@LAPTOP-DOA:~/Document/Ch7$ ./Program1 &amp;</span><br><span class="line">[1] 75</span><br><span class="line">doa@LAPTOP-DOA:~/Document/Ch7$ Printing from Lib.so 1</span><br><span class="line">^C</span><br><span class="line">doa@LAPTOP-DOA:~/Document/Ch7$ cat /proc/75/maps</span><br><span class="line">7fffba250000-7fffba253000 rw-p 00000000 00:00 0</span><br><span class="line">7fffba260000-7fffba285000 r--p 00000000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba285000-7fffba3fd000 r-xp 00025000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba3fd000-7fffba447000 r--p 0019d000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba447000-7fffba448000 ---p 001e7000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba448000-7fffba44b000 r--p 001e7000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba44b000-7fffba44e000 rw-p 001ea000 00:00 289858             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7fffba44e000-7fffba452000 rw-p 00000000 00:00 0</span><br><span class="line">7fffba460000-7fffba461000 r--p 00000000 00:00 23019              /home/doa/Document/Ch7/Lib.so</span><br><span class="line">7fffba461000-7fffba462000 r-xp 00001000 00:00 23019              /home/doa/Document/Ch7/Lib.so</span><br><span class="line">7fffba462000-7fffba463000 r--p 00002000 00:00 23019              /home/doa/Document/Ch7/Lib.so</span><br><span class="line">7fffba463000-7fffba464000 r--p 00002000 00:00 23019              /home/doa/Document/Ch7/Lib.so</span><br><span class="line">7fffba464000-7fffba465000 rw-p 00003000 00:00 23019              /home/doa/Document/Ch7/Lib.so</span><br><span class="line">7fffba470000-7fffba472000 rw-p 00000000 00:00 0</span><br><span class="line">7fffba480000-7fffba481000 r--p 00000000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba481000-7fffba4a3000 r-xp 00001000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4a3000-7fffba4a4000 r-xp 00023000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4a4000-7fffba4ab000 r--p 00024000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4ab000-7fffba4ac000 r--p 0002b000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4ad000-7fffba4ae000 r--p 0002c000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4ae000-7fffba4af000 rw-p 0002d000 00:00 289671             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7fffba4af000-7fffba4b0000 rw-p 00000000 00:00 0</span><br><span class="line">7fffba4b0000-7fffba4b1000 r--p 00000000 00:00 23152              /home/doa/Document/Ch7/Program1</span><br><span class="line">7fffba4b1000-7fffba4b2000 r-xp 00001000 00:00 23152              /home/doa/Document/Ch7/Program1</span><br><span class="line">7fffba4b2000-7fffba4b3000 r--p 00002000 00:00 23152              /home/doa/Document/Ch7/Program1</span><br><span class="line">7fffba4b3000-7fffba4b4000 r--p 00002000 00:00 23152              /home/doa/Document/Ch7/Program1</span><br><span class="line">7fffba4b4000-7fffba4b5000 rw-p 00003000 00:00 23152              /home/doa/Document/Ch7/Program1</span><br><span class="line">7fffbc820000-7fffbc841000 rw-p 00000000 00:00 0                  [heap]</span><br><span class="line">7fffc4172000-7fffc4972000 rw-p 00000000 00:00 0                  [stack]</span><br><span class="line">7fffc4bab000-7fffc4bac000 r-xp 00000000 00:00 0                  [vdso]</span><br><span class="line">doa@LAPTOP-DOA:~/Document/Ch7$</span><br></pre></td></tr></table></figure>
<p>可以看到其中不止有Program1的映射，还有<code>libc-2.31.so</code> 、<code>Lib.so</code> 、<code>ld-2.31.so</code> 等共享对象，其中<code>libc-2.31.so</code>是动态链接的C语言运行库 ，<code>ld-2.31.so</code>是Linux下的<strong>动态链接器</strong>。再开始执行Program1之前，系统会把控制权交给动态链接器，并由它完成所有的动态链接工作，然后再把控制权交还给Program1，开始执行。</p>
<h3 id="7-3-地址无关代码"><a href="#7-3-地址无关代码" class="headerlink" title="7.3 地址无关代码"></a>7.3 地址无关代码</h3><p>动态链接需要在开始执行程序之前对各个模块中对数据和引用的地址进行确定，也就是静态链接时的重定位。动态链接实现重定位的方式有两种：</p>
<ul>
<li>装载时重定位</li>
<li><strong>地址无关代码（Position-Independent Code, PIC）</strong></li>
</ul>
<p>装载时重定位很简单，就是在模块装载时先确定装载地址（目标地址/基地址），然后依据这个装载地址修改其中的绝对地址引用进行重定位（因为模块是按照一个整体被装载的，所以代码和数据之间的相对位置是不会改变的）</p>
<p><strong>这种方式的缺点就是，一个共享对象的指令部分不能被多个进程所共享</strong>，仍然起不到节省内存空间的作用。因为指令部分中的引用在装载时被修改后就与进程相关了，取决于这个共享对象在该进程虚拟空间中被分配的地址，是一个固定值，而对于不同的进程，该共享对象的虚拟地址都是不一样的，所以一份指令不能被多个进程所共享。</p>
<p>解决这个问题的方法就是地址无关代码技术，一开始听起来很nb，其实就是在指令部分和被引用的地址之间增加了一层，这一层称为<strong>全局偏移表（Global Offset Table，GOT）</strong>，在共享对象文件中是名为<code>.got</code>的段。</p>
<p>我们在上一节中生成<code>Lib.so</code>的时候就使用了<code>-fPIC</code>参数，从而产生使用了<code>PIC</code>技术的动态共享库。</p>
<p><strong>我们的使用这种技术的目的是希望共享模块的指令部分与装载地址无关，从而能被多个进程共享。</strong>于是，一个自然的想法就是把指令中那些需要修改的部分分离出来，放在数据部分，因为每个进程都有单独的一个数据部分的副本，从而可以满足我们的需求。<code>PIC</code>主要是针对，共享模块中对模块外部数据or函数的访问or调用（后简写访问），因为内部数据和函数的访问都可以使用相对跳转来实现，而外部数据和函数则不能（因为相对位置会变化）。</p>
<p>于是我们请出GOT，我们并不直接访问外部数据和函数，而是将指令中对外部数据和函数的直接访问改为访问一个GOT表中的固定位置的指针（这些指针是固定放在数据部分的某个位置的，且排序也固定，所以GOT本质上是一个指针数组）。</p>
<p><img src="/2021/04/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/7.4-%E6%A8%A1%E5%9D%97%E9%97%B4%E6%95%B0%E6%8D%AEand%E5%87%BD%E6%95%B0%E8%AE%BF%E9%97%AE.png" alt="7.4-模块间数据and函数访问" style="zoom: 50%;"></p>
<center>图7.4 模块间数据and函数访问</center>

<p>每个指针在GOT中的位置是固定的，所以指令部分的地址也就是固定的了，是不是很巧妙？</p>
<p>代码中对函数和数据的访问大致可以分为以下四种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;	<span class="comment">//注意这里是静态全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;	<span class="comment">//类型2 模块内部数据访问</span></span><br><span class="line">    b = <span class="number">2</span>;	<span class="comment">//类型4 模块外部数据访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bar();	<span class="comment">//类型1 模块内部函数调用</span></span><br><span class="line">    ext();	<span class="comment">//类型3 模块外部函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center> 表7.1 不同类型的函数、数据访问方式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>指令跳转、调用</th>
<th>数据访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块内部</td>
<td>（1）相对跳转和调用</td>
<td>（2）相对地址访问</td>
</tr>
<tr>
<td>模块外部</td>
<td>（3）间接跳转和调用（GOT）</td>
<td>（4）直接访问（GOT）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意！</strong>对于模块内部的静态全局变量来说，是可以直接用相对寻址的方式访问的，而<strong>对于模块内部的非静态全局变量来说</strong>，却不能，因为编译器无法确定对全局变量的引用是跨模块的还是模块内部的。因此，<strong>无论是模块内部还是外部的全局变量，都只能使用GOT的方式来访问</strong>。可执行文件在生成代码的过程中，在链接过程中就要确定地址，这时，链接器会在<code>.bss</code>段创建一个该全局变量的副本，在之后的动态连接过程中，其他模块的GOT都会指向该副本，从而不会导致冲突。</p>
<h4 id="7-3-5-数据段地址无关"><a href="#7-3-5-数据段地址无关" class="headerlink" title="7.3.5 数据段地址无关"></a>7.3.5 数据段地址无关</h4><p>我们之前讨论的都是指令（代码）部分的地址无关性，其实数据段里面也有绝对地址的引用问题，例如一个指针变量p指向一个全局/静态变量a，a的地址会随着不同进程的装载而不同，解决这个问题的方法是<strong>利用重定位表</strong>，其中包含a的重定位信息，在动态装载的时候就会被重定位。</p>
<p><strong>装载时重定位和地址无关代码的优缺</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>装载时重定位</th>
<th>地址无关代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>运行速度较PIC方案要快</td>
<td>代码部分能被共享</td>
</tr>
<tr>
<td>缺点</td>
<td>代码部分不能被共享</td>
<td>比装载时重定位的方法运行时多了计算当前地址以及间接寻址的过程</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>对于动态连接的可执行文件，GCC默认会使用PIC的方法产生可执行文件的代码段部分。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>动态链接</tag>
        <tag>插件</tag>
        <tag>地址无关代码技术</tag>
        <tag>全局偏移表</tag>
        <tag>GOT</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》 Ch6 可执行文件的装载与进程</title>
    <url>/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>在讲装载之前，我们首先要了解程序和进程的区别，我用一种不严谨的说法来一句话解释：硬盘中的程序被装载到内存中就变成了进程。</p>
<blockquote>
<p>程序（狭义上是可执行文件）是一个静态概念，它是一些预先编译好的指令和数据的集合的一个文件；进程则是一个动态的概念，它是程序运行时的一个过程，或者讲，一个正在运行的程序。很多时候把动态库叫做运行时（Runtime）就有这种含义。</p>
<p>有一个很形象的比喻就是，程序是一个大厨做菜时的菜谱，计算机的CPU相当于这个大厨，相关的厨具就是计算机的其他硬件，整个做菜的过程就是一个进程。</p>
</blockquote>
<p>所谓装载，就是把存储在硬盘等介质内的程序（指令和数据），加载到内存中的某个位置，然后才能由CPU执行。这是由传统的冯·诺伊曼结构的所决定的（学过计组的都懂）。</p>
<a id="more"></a>
<h3 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h3><p>现代计算机系统的内存中，可以同时存在许多进程，为了防止这些进程在运行的过程中相互干扰，同时也可以防止恶意程序（病毒）对其他进程的破坏，操作系统（OS）中的每个进程都有自己独立的<strong>虚拟地址空间（Virtual Address Space）</strong>。虚拟地址空间的大小由CPU的地址总线的位数决定，32位的为4G，64位就有很多很多了（多到目前为止可以看作是无限的）。</p>
<p>本书的讨论都是在32位的环境下。</p>
<p>无论是Windows还是Linux下，一个进程的4G虚拟地址空间的主要分为两部分：操作系统部分和用户进程部分。为什么操作系统也要在用户进程的虚拟地址空间中占用一部分空间？我的想法是，因为要保证用户进程在操作系统的监控之下运行，因为不同进程间的虚拟地址空间是相互独立的，如果OS（OS是一个特殊的进程）独立于用户进程，那么OS就没法对该进程进行监控了，该用户进程也不能调用OS的系统调用了（以上来自于一个没有系统学过OS的人的“猜想”）。</p>
<p>Linux默认占用1G的虚拟地址空间，Windows默认占用2G，不过可以通过修改<code>Boot.ini</code>文件来修改Windows占用的空间。</p>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6.1-Linux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.png" alt="6.1-Linux进程虚拟空间分布" style="zoom: 33%;"></p>
<center>图6-1 Linux进程虚拟空间分布</center>



<h4 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h4><p>在32位时代，为了扩大可用的内存空间，有些厂商把CPU的地址总线位数进行了扩展（使之超过CPU数据总线的位数），例如：Intel 1995年的Pentium Pro CPU开始采用了36位的物理地址，但它本身是一个32位的CPU。</p>
<p>那么如何利用这些高于32位地址空间的内存呢？Intel是通过修改页映射的方式来实现的，这种地址扩展方式就成为<strong>PAE（Physical Address Extension）</strong>，因为是物理上扩展了地址空间。</p>
<blockquote>
<p>一个常见的实现就是OS提供一个窗口映射的方法，把额外的内存映射到进程地址空间来。应用程序可以跟据需要来选择申请和映射，比如一个应用程序中的<code>0x10000000~0x20000000</code>这一段256MB的虚拟地址空间作为<strong>窗口</strong>，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，并依次编号，如：A、B、C。然后可以根据需要将窗口映射到不同的空间去，例如需要用到A块中的内容是，就把窗口对应的地址映射到A的实际物理地址，然后就可以通过访问窗口范围的地址来访问A块中的地址了，同理，需要用到B中的内容是，可以将窗口映射到B块。在Windows下，这种操作方式叫做<strong>AWE（Address Windowing Extensions）</strong>。</p>
</blockquote>
<h3 id="6-2-装载的方式"><a href="#6-2-装载的方式" class="headerlink" title="6.2 装载的方式"></a>6.2 装载的方式</h3><p>最简单的装载就是一次性把程序的所有内容都装载到内存中，可是内存空间是极为珍贵的，很多时候并不能满足程序的要求。同时，跟据程序运行的局部性原理，我们可以只把程序的一部分留在内存中，其他部分放在硬盘中，等用到的时候再装入内存，这就是<strong>动态装载</strong>的基本原理。</p>
<p>动态装载的常用方法有两种：<strong>覆盖装入（Overlay）</strong>和<strong>页映射（Paging）</strong>。</p>
<h4 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h4><p>覆盖装入在虚拟存储发明之前使用得比较广泛，现在几乎被淘汰了，因为它比较的使用很麻烦，需要由程序员自己写一个<strong>覆盖管理器（Overlay Manager）</strong>，来管理程序不同部分（模块）的装载。</p>
<blockquote>
<p>在多个模块的情况下，需要程序员手动将模块按照他们之间的调用关系组织成树状结构（如图）。</p>
</blockquote>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6-2%20%E8%A6%86%E7%9B%96%E8%A3%85%E5%85%A5%E8%B0%83%E7%94%A8%E6%A0%91%E7%8A%B6%E5%9B%BE.png" alt="6-2 覆盖装入调用树状图" style="zoom:33%;"></p>
<center> 6-2 覆盖装入调用树状图</center>

<p>图中，同一高度代表同一内存地址，所以有重叠的模块是不能同时存在的。树中的子节点（模块）是依赖于父节点的，也就是说子节点存在于内存中的时候，父节点也要存在。</p>
<p>这也就引出了这种方法所需要注意的两个问题：</p>
<ol>
<li>一个模块的调用路径（也就是从树根main模块，到这模块上的所有途经模块所构成的路径）都必须在内存中，才能保证程序的依赖关系</li>
<li>跨树间的调用是被禁止的。因为跨树会导致模块的内存重叠冲突，不同的路径不能同时存在于内存中。</li>
</ol>
<h4 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h4><p>页映射是虚拟存储机制的一部分。它的原理就是把可执行文件和内存空间都分为许多大小一致的“页”（Intel IA32的页是4KB），当进程运行到某一部分的代码不存在于内存中时，就发生“缺页中断”，把需要的页加载到内存中。同时，如果内存的页都被占满了，这时我们需要选择一个页被替换掉，选择的方法有许多，例如：FIFO、LUR等页替换算法。</p>
<p>在这种方法中，OS就充当着覆盖管理器的角色，更具体的说，是OS的存储管理器。</p>
<h3 id="6-3-从操作系统的角度看可执行文件的装载"><a href="#6-3-从操作系统的角度看可执行文件的装载" class="headerlink" title="6.3 从操作系统的角度看可执行文件的装载"></a>6.3 从操作系统的角度看可执行文件的装载</h3><p>从操作系统的角度来看，可执行文件的装载主要包含两个大的操作：</p>
<ol>
<li>进程的建立</li>
<li>页错误</li>
</ol>
<h4 id="6-3-1-进程的建立"><a href="#6-3-1-进程的建立" class="headerlink" title="6.3.1 进程的建立"></a>6.3.1 进程的建立</h4><p>创建一个进程分为三步：</p>
<ol>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ol>
<blockquote>
<p><strong>创建虚拟地址空间</strong> 一个虚拟空间由一组页映射函数<strong>将虚拟空间的各个页映射至相应的物理空间</strong>，那么创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。</p>
<p><strong>读取可执行文件头，并建立虚拟空间与可执行文件的映射关系</strong> 第一步完成的是虚拟空间到物理空间的映射关系，而这一步完成的是虚拟空间与可执行文件之间的映射。是装载过程中最重要的一步。</p>
<p>Linux中把虚拟进程空间中的一个连续的地址空间叫做<strong>虚拟内存区域（VMA，Virtual Memory Area）</strong>，Windows中叫做虚拟段（Virtual Section）。一般一个VMA一半对应一个段（一个或多个页）。</p>
<p><a href="https://baike.baidu.com/item/VMA/9839255" target="_blank" rel="noopener">https://baike.baidu.com/item/VMA/9839255</a></p>
<p><strong>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</strong> 这一步是最简单的一步，它将CPU的控制权由OS转交给进程，由此进程开始执行。</p>
</blockquote>
<h4 id="6-3-2-页错误"><a href="#6-3-2-页错误" class="headerlink" title="6.3.2 页错误"></a>6.3.2 页错误</h4><p>完成上面的步骤，程序其实还没有被装载到内存中，因为只是建立了映射关系，并没有真正映射。</p>
<p>当CPU执行到程序的入口地址（以0x8048000这个虚拟地址为例），发现这个页并没有被加载到物理内存中（通过一个数据结构可得到这个信息），于是就产生一个“页错误（Page Fault）”，引发缺页中断，CPU的控制权转交给OS，由OS分配一个物理页，建立映射关系，将缺少的页加载到该物理页中，然后将CPU的控制权交还给进程，继续执行。</p>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6.3-%E9%A1%B5%E9%94%99%E8%AF%AF.png" alt="6.3-页错误" style="zoom:33%;"></p>
<center>图6-3 页错误发生后</center>



<h3 id="6-4-进程虚存空间分布"><a href="#6-4-进程虚存空间分布" class="headerlink" title="6.4 进程虚存空间分布"></a>6.4 进程虚存空间分布</h3><h4 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h4><p>现代OS的装载过程实际采用的是页映射的方式，也就是以页为单位装载指令和数据的，所以存在一个页地址对齐的问题。也就是不同段（Section）映射到虚拟内存空间或实际物理空间的时候，占用的空间必须是页大小的整数倍（起始地址也是）。</p>
<p>但是随着可执行文件中段的数量不断增多（特别是ELF，一个ELF往往有十几个段），就会产生内存碎片的问题，有许多段本身或者末尾实际仅仅使用了一个页的一小部分，造成了极大的浪费。</p>
<p>解决的方案就是，尽可能合并这些段（合并后的称为Segment），然后<strong>将合并后的Segment作为一个整体映射到虚拟内存空间和实际物理空间，并且一个Segment对应一个VMA（Virtual Memory Area）</strong>。这里的Segment翻译过来其实也称为段，只不过是在装载过程中的段，在讨论装载的情况下，段这个字一般都指的是Segment。</p>
<p>那按照什么来合并呢？总不能一股脑儿地把所有段都合并了吧，这样不利于程序内部的结构划分。</p>
<p>ELF采用的方案是<strong>把具有相同权限（读、写、执行）的段合并成一个Segment</strong>，ELF中主要的段的权限组合不多，主要有3种：</p>
<blockquote>
<ul>
<li>以代码段为代表的权限为可读可执行的段</li>
<li>以数据段和BSS段为代表的权限为可读可写的段</li>
<li>以只读数据段为代表的权限为只读的段</li>
</ul>
</blockquote>
<p>ELF中描述Segment的结构叫做<strong>程序头（Program Header）</strong>，很容易与之前说过的段表（Section Header Table）弄混。</p>
<p>我们用readelf查看如下程序的程序头，得到如下结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">doa@LAPTOP-DOA:~/Document$ readelf -l SectionMapping.elf</span><br><span class="line">Elf file <span class="built_in">type</span> is EXEC (Executable file)</span><br><span class="line">Entry point 0x401bc0</span><br><span class="line">There are 10 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000518 0x0000000000000518  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000</span><br><span class="line">                 0x00000000000935dd 0x00000000000935dd  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000</span><br><span class="line">                 0x00000000000265f5 0x00000000000265f5  R      0x1000</span><br><span class="line">  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000005170 0x00000000000068c0  RW     0x1000</span><br><span class="line">  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000000020 0x0000000000000060  R      0x8</span><br><span class="line">  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000002f40 0x0000000000002f40  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt</span><br><span class="line">   01     .init .plt .text __libc_freeres_fn .fini</span><br><span class="line">   02     .rodata .stapsdt.base .eh_frame .gcc_except_table</span><br><span class="line">   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs</span><br><span class="line">   04     .note.gnu.property</span><br><span class="line">   05     .note.gnu.build-id .note.ABI-tag</span><br><span class="line">   06     .tdata .tbss</span><br><span class="line">   07     .note.gnu.property</span><br><span class="line">   08</span><br><span class="line">   09     .tdata .init_array .fini_array .data.rel.ro .got</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以总的来说，“Segment”和“Section”是从不同角度来划分同一个ELF文件，这个在ELF中被称为不同的<strong>视图（View）</strong>，从“Section”的角度来看ELF文件就是<strong>链接视图（Linking View）</strong>，从“Segment”的角度来看就是<strong>执行视图（Execution View）</strong>。</p>
</blockquote>
<h4 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h4><p>在OS中，VMA除了被用来映射可执行文件中的各个Segment，OS还通过使用VMA来对进程的地址空间进行管理。例如进程在运行时还需用到的<strong>堆（Heap）</strong>和<strong>栈（Stack）</strong>等空间，他们在虚拟内存空间中的表现形式也是VMA。</p>
<p>在linux下，可以通过查看<code>/proc</code>来查看进程的虚拟空间分布：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">doa@LAPTOP-DOA:~/Document$ cat /proc/184/maps</span><br><span class="line">00400000-00401000 r--p 00000000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">00401000-00494000 r-xp 00001000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">00494000-00495000 r-xp 00094000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">00495000-004bb000 r--p 00095000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">004bb000-004bc000 r--p 000bb000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">004bd000-004c0000 r--p 000bc000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">004c0000-004c3000 rw-p 000bf000 00:00 963148                     /home/doa/Document/SectionMapping.elf</span><br><span class="line">004c3000-004c4000 rw-p 00000000 00:00 0</span><br><span class="line">006ed000-00710000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fffe2ba2000-7fffe33a2000 rw-p 00000000 00:00 0                  [stack]</span><br><span class="line">7fffe33da000-7fffe33db000 r-xp 00000000 00:00 0                  [vdso]</span><br></pre></td></tr></table></figure>
<p>其中最后两列分别指映像文件的节点号和路径。</p>
<p>向堆和栈这种没有指定特定的映像文件的VMA通常称为<strong>匿名虚拟内存区域（Anonymous Virtual Memory Area）</strong>。每个线程都有自己的堆和栈，C语言中使用malloc()内存分配函数就是分配堆中的内存。<br>可以看到其中还有一个非常特殊的VMA叫做<code>[vsdo]</code>，实际上它是OS内核的一个模块，进程可以通过访问这个VMA来跟内核进行通信。</p>
<blockquote>
<p>进程虚拟地址空间的概念：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的，有相同映像文件的映射成一个VMA，一个进程基本上可以分为如下几种VMA区域：</p>
<ul>
<li>代码VMA，权限只读、可执行；有映像文件</li>
<li>数据VMA，权限可读写、可执行；有映像文件</li>
<li>堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展</li>
<li>栈VMA，权限可读写、不可知性；无映像文件，匿名，可向下扩展</li>
</ul>
</blockquote>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6.4-ELF%E4%B8%8ELinux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="6.4-ELF与Linux进程虚拟空间映射关系" style="zoom:33%;"></p>
<center> 图6-4 ELF与Linux进程虚拟空间映射关系</center>



<h4 id="6-4-3-堆的最大申请数量"><a href="#6-4-3-堆的最大申请数量" class="headerlink" title="6.4.3 堆的最大申请数量"></a>6.4.3 堆的最大申请数量</h4><p>略</p>
<h4 id="6-4-4-段地址对齐"><a href="#6-4-4-段地址对齐" class="headerlink" title="6.4.4 段地址对齐"></a>6.4.4 段地址对齐</h4><p>前面我们说到为了节省由于页对齐产生的内存碎片，而想出和并为Segment的方法。但这并不能满足人类贪婪的欲望，即使是只剩三个Segment了，还是有很大可能多浪费了两个页，为了节省这两个页，我们需要进一步“合并”Segment，<strong>但这种合并与之前的合并为Segment并不一样！！！合并为Segment是在虚拟地址空间和物理空间两个地方都进行合并，而将Segment合并仅仅是在物理空间合并，在虚拟地址空间中的操作是将两个Segment交接处所在的页映射两次。</strong>这么说可能有些抽象，上图：</p>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6.5-ELF%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.5-ELF文件合并情况" style="zoom:50%;"></p>
<center>图6-5 ELF文件段合并情况</center>

<p>至于为什么虚拟地址空间中不直接合并，我个人的猜想是因为OS层面访问的都是虚拟地址，OS需要区分不同的Segment以判断权限（因为内存权限的最小粒度是页），所以不同Segment在虚拟地址空间中不能在一个页中有交集，否则虚拟地址空间中的同一个页的权限会有冲突。</p>
<p>如果按照正常的映射方式，3个段（SEG0、SEG1、SEG2）应该分别占用1、3、1个Page（物理内存中），总共占用5个，如下图：</p>
<p><img src="/2021/03/30/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/6.6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%AE%B5%E6%9C%AA%E5%90%88%E5%B9%B6%E6%83%85%E5%86%B5.png" alt="6.6-可执行段未合并情况" style="zoom:50%;"></p>
<center>图6-6 可执行文件段未合并情况</center>

<h3 id="6-5-Linux内核装在ELF过程简介"><a href="#6-5-Linux内核装在ELF过程简介" class="headerlink" title="6.5 Linux内核装在ELF过程简介"></a>6.5 Linux内核装在ELF过程简介</h3><blockquote>
<p>在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，是原先的bash进程继续返回等待各个启动的新进程结束，然后继续等待用户输入命令。</p>
</blockquote>
<p>剩下的用到再查（狗头</p>
<h3 id="6-6-Windows-PE的装载"><a href="#6-6-Windows-PE的装载" class="headerlink" title="6.6 Windows PE的装载"></a>6.6 Windows PE的装载</h3><blockquote>
<p>PE与ELF不一样，PE可执行文件的段的数量一般很少，这是因为链接器在产生可执行文件的时候就尽可能地把段合并，最后一般只剩下代码段、数据段、只读数据段和BSS等为数不多的几个段。</p>
<p>PE中有一个很常见的术语叫做RVA（Relative Virtual Address），其实就是相当于文件中的偏移量。它是相对于PE文件的装载机地址的偏移地址。比如一个PE文件被装载到虚拟地址（VA）0x00400000，那么一个RVA为0x1000的地址就是0x00401000。</p>
<p>每个PE文件在装载<strong>目标地址（Target Address）</strong>，这个地址就是<strong>基地址（Base Address）</strong>。因为PE文件可以被装载到任何地址，所以这个及地址不是固定的，每次装载时都会变化。</p>
<p>装在一个PE可执行文件的过程：</p>
<ul>
<li>读取文件的第一个页，在这个页中包含了DOS头、PE文件头和段表</li>
<li>检查进程虚拟地址空间中，目标地址是否可用，如果不可用，则选另外一个装在地址。这个问题对于可执行文件来说基本不存在，因为它往往是进程第一个装载的模块，所以目标地址不太可能被占用。这里主要是针对DLL文件的装载而言的，后面还有“Rebasing”这一节会具体介绍这个问题。</li>
<li>使用段表中提供的信息，将PE文件中所有的段一一映射到地址空间中的相应位置。</li>
<li>如果装载地址不是目标地址，则进行Rebasing。</li>
<li>装载所有PE文件所需要的DLL文件</li>
<li>对PE文件中的所有导入符号进行解析</li>
<li>跟据PE头中指定的参数，建立初始化栈和堆。</li>
<li>建立主线程并启动进程。</li>
</ul>
</blockquote>
<p>PE文件中，与装载有关的主要信息都包含在PE扩展头（PE Optional Header）和段表中了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>进程</tag>
        <tag>可执行文件的装载</tag>
        <tag>虚拟地址空间</tag>
        <tag>Segment</tag>
        <tag>页映射</tag>
        <tag>链接视图</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》 Ch5 Windows PE/COFF</title>
    <url>/2021/03/03/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch5-Windows-PE-COFF/</url>
    <content><![CDATA[<p>Windows下的可执行文件格式为PE（Portable Executable），与ELF格式同根同源，都是COFF（Common Object File Format）格式的一种扩展。所以它们之间基本结构相同，下文主要说明它两之间的差异。</p>
<p>我们可以用dumpbin查看obj文件的信息，输入<code>/ALL</code>参数可以查看所有相关信息：</p>
<p><code>dumpbin /ALL SimpleSection.obj &gt; SimpleSection.txt</code></p>
<a id="more"></a>
<h3 id="PE的前身COFF文件"><a href="#PE的前身COFF文件" class="headerlink" title="PE的前身COFF文件"></a>PE的前身COFF文件</h3><p><img src="/2021/03/03/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch5-Windows-PE-COFF/5.2-COFF%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.2-COFF目标文件格式" style="zoom:33%;"></p>
<center>图5-1 COFF目标文件格式</center>

<p>COFF与之前介绍的ELF文件的一个主要不同就是，COFF的头文件包括两部分，一个是映像头（Image Header），类比ELF中的文件头，描述文件的总体结构和属性；第二个是段表（Section Table），而在ELF中，段表不是紧挨着文件头的。这个结构是一个数组结构，数组大小等于段的数量。</p>
<blockquote>
<p>映像（Image）：因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件也被称为<strong>映像文件（Image File）</strong></p>
</blockquote>
<p>COFF文件的映像头对应的数据结构是<code>_IMAGE_FILE_HEADER</code>，书上说定义在<code>VC\PlatformSDK\include\WinNT.h</code>中，不过这应该是在作者那个年代的VC版本，我在自己电脑上的Visual Studio 2019 community的目录找了一下，并没有找到。该文件在win10下的目录应该是<code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\</code>（版本号可能有所不同），前提是你安装了Windows SDK，文件名为<code>winnt.h</code>，数据结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD Machine;</span><br><span class="line">    WORD NumberOfSections;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    DWORD PointerToSymbolTable;</span><br><span class="line">    DWORD NumberOfSymbols;</span><br><span class="line">    WORD SizeOfOptionalHeader;</span><br><span class="line">    WORD Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
<p>这些字段的含义看命名应该很容易理解，知道有这些东西就行，具体需要用到的时候再百度。</p>
<p>同时，段表对应的数据结构定义为<code>_IMAGE_SECTION_HEADER</code>，也位于<code>winnt.h</code>文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">		DWORD PhysicalAddress;</span><br><span class="line">		DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD VirtualAddress;</span><br><span class="line">    DWORD SizeOfRawData;</span><br><span class="line">    DWORD PointerToRawData;</span><br><span class="line">    DWORD PointerToRelocations;</span><br><span class="line">    DWORD PointerToLinenumbers;</span><br><span class="line">    WORD NumberOfRelocations;</span><br><span class="line">    WORD NumberOfLinenumbers;</span><br><span class="line">    DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>字段含义就不说了，理由同上，不过有一个点需要说一下，就是<code>SizeOfRawData</code>字段指的是该段在文件中的大小，而<code>VirtualSize</code>则是该段被加载到内存后的实际大小，这两个大小可能会不一样，且往往是前者比后者小。例如，bss段的<code>SizeOfRawData</code>为0，而<code>VirtualSize</code>则为bss段所含数据的大小。</p>
<h3 id="链接指示信息"><a href="#链接指示信息" class="headerlink" title="链接指示信息"></a>链接指示信息</h3><blockquote>
<p>COFF中<code>.drectve</code>段的内容是编译器传递给链接器的指令（Directive），即编译器希望告诉连接器该怎样链接这个目标文件。</p>
</blockquote>
<h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>COFF中所有以<code>.debug</code>开头的段都包含着调试信息，例如<code>.debug$S</code>包含的是符号（Symbol）相关的调试信息；<code>.debug$P</code>包含的是预编译头文件（Precompile）相关的调试信息；<code>.debug$T</code>包含的是类型（Type）相关的调试信息。</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>dumpbin输出的最后一部分是COFF的符号表，总共有6列，从左到右依次是：符号编号、符号所表示的对象所占空间、符号所在位置、符号类型、符号可见范围、符号名（修饰后和修饰前）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COFF SYMBOL TABLE</span><br><span class="line">000 010471B7 ABS    notype       Static       | @comp.id</span><br><span class="line">001 80000191 ABS    notype       Static       | @feat.00</span><br><span class="line">002 00000000 SECT1  notype       Static       | .drectve</span><br><span class="line">    Section length   18, #relocs    0, #linenums    0, checksum        0</span><br><span class="line">004 00000000 SECT2  notype       Static       | .debug$S</span><br><span class="line">    Section length   B8, #relocs    0, #linenums    0, checksum        0</span><br><span class="line">006 00000000 SECT3  notype       Static       | .data</span><br><span class="line">    Section length    C, #relocs    0, #linenums    0, checksum AC5AB941</span><br><span class="line">008 00000000 SECT3  notype       External     | _global_init_var</span><br><span class="line">009 00000004 UNDEF  notype       External     | _global_uninit_var</span><br><span class="line">00A 00000000 SECT4  notype       Static       | .text$mn</span><br><span class="line">    Section length   4E, #relocs    5, #linenums    0, checksum CC61DB94</span><br><span class="line">00C 00000000 UNDEF  notype ()    External     | _printf</span><br><span class="line">00D 00000000 SECT4  notype ()    External     | _func1</span><br><span class="line">00E 00000020 SECT4  notype ()    External     | _main</span><br><span class="line">00F 00000004 SECT3  notype       Static       | $SG6034</span><br><span class="line">010 00000008 SECT3  notype       Static       | ?static_var@?1??main@@9@9 (&#96;main&#39;::&#96;2&#39;::static_var)</span><br><span class="line">011 00000000 SECT5  notype       Static       | .bss</span><br><span class="line">    Section length    4, #relocs    0, #linenums    0, checksum        0</span><br><span class="line">013 00000000 SECT5  notype       Static       | ?static_var2@?1??main@@9@9 (&#96;main&#39;::&#96;2&#39;::static_var2)</span><br><span class="line">014 00000000 SECT6  notype       Static       | .chks64</span><br><span class="line">    Section length   30, #relocs    0, #linenums    0, checksum        0</span><br></pre></td></tr></table></figure>
<p>第三列的ABS表示对象所占空间，SECTx表示对象定义在第x个段，UNDEF表示符号在本文件中未定义，被定义在其他文件。</p>
<p>第四列的notype表示变量和其他符号类型，notype()则表示函数类型。</p>
<p>第五列的Static表示符号是局部变量，仅在本目标文件内可见，External则是全局可见的，可被其他目标文件引用。</p>
<h3 id="Windows下的ELF——PE"><a href="#Windows下的ELF——PE" class="headerlink" title="Windows下的ELF——PE"></a>Windows下的ELF——PE</h3><p><img src="/2021/03/03/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch5-Windows-PE-COFF/5.6-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="5.6-PE文件格式" style="zoom:33%;"></p>
<center>图5-2 PE文件格式</center>

<p>PE文件在COFF的格式基础上，又有一些变化：</p>
<p>首先文件开头添加了DOS MZ可执行文件格式的文件头和桩代码（DOS MZ File Header and Stub）；第二，COFF的<code>IMAEG_FILE_HEADER</code>扩展为了<code>IMAGE_NT_HEADER</code>，其中添加了<code>IMAGE_OPTIONAL_HEADER32</code>部分。</p>
<p>之所以要添加DOS MZ相关的头文件和桩代码，是为了使为Windows编写的程序能“兼容”原有的DOS系统，以至于在DOS系统下不会被执行而导致错误。</p>
<p>其中<code>IMAGE_DOS_HEADER</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>
<p>其中<code>e_magic</code>这个字段是“魔数”，简单来说就是用来区分不同文件类型的，详细可以看：<a href="https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)，PE的该字段包括“MZ”这两个字母的ASCII码。" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)，PE的该字段包括“MZ”这两个字母的ASCII码。</a></p>
<p>其他字段中最重要的就是<code>e_cs</code>和<code>e_ip</code>这两个了，这两个字段的值指向程序的入口地址。</p>
<p>在DOS系统下运行PE文件，会因为魔数而检测到PE文件是一个“MZ”格式的文件，然后开始读取<code>e_cs</code>和<code>e_ip</code>的值准备执行，但其本质还是PE文件，且PE文件中这两个字段指向的并不是真正的程序入口地址，而是指向<code>DOS Stub</code>的起始位置，<code>DOS Stub</code>是可以在DOS下运行的一小段代码，这段代码唯一的作用是向终端输出一行字符串：“This program cannot be run in DOS”，然后就退出程序，这样就防止了在DOS下执行PE可能导致的错误。</p>
<p><code>IMAGE_OPTIONAL_HEADER32</code>字面上是可选的，但实际上对于PE来说，是必须的，因为其中包含了很多对于PE执行来说重要的信息，比如<code>DataDirectory</code>。但是我们不必熟知，用到的时候再查即可，具体结构就不展示了。</p>
<h3 id="PE-数据目录"><a href="#PE-数据目录" class="headerlink" title="PE 数据目录"></a>PE 数据目录</h3><p>数据目录是一个数据结构——<code>_IMAGE_DATA_DIRECTORY</code>，定义为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p>这个数据结构描述了PE文件中其他数据结构（如导入表、导出表、资源表、重定位表等）的虚拟地址和大小。</p>
<p>上一节最后的可选头文件中就包含了一个数据目录的数组，每一个元素对应一个表，以让系统很方便的找到所要用的表。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>COFF</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》 Ch4 静态链接</title>
    <url>/2021/02/05/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch4-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>所谓静态链接，就是在链接阶段把所有参与链接的目标文件合并到一个最终的可执行文件中。有静态就有动态，后面会讲的动态链接就是链接过程中只是指明了主程序在运行时需要哪些动态链接库（模块），最终链接得到的可执行文件并没有包含所有模块的代码，而是在运行过程中会动态地加载那些模块。</p>
<a id="more"></a>
<h3 id="静态链接的过程"><a href="#静态链接的过程" class="headerlink" title="静态链接的过程"></a>静态链接的过程</h3><p>从目标文件到最终的可执行文件，主要分为两步：</p>
<ol>
<li><strong>空间与地址分配</strong>，这里的空间指的是目标文件的段在可执行文件中的空间位置，地址指的是每一条指令的虚拟地址，此步骤完成后就能确定目标文件中全局符号在可执行文件中的实际位置（虚拟地址），为第2步做准备。</li>
<li><strong>符号解析与重定位</strong>，即根据重定位表的信息和第1步得到的全局符号地址对引用位置的地址进行更新。</li>
</ol>
<h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>从前面的章节可以知道，每一个目标文件都是许多段组成的，要把许多目标文件这么多不同的段合并到最终的可执行文件里，一个很自然的想法就是把不同文件中的同一种段（.text或.data或其他的）合并成一个段，实际采用的就是这种方案。</p>
<p><img src="/2021/02/05/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-Ch4-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/4-1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="4-1空间分配策略" style="zoom:33%;"></p>
<center>图4-1 空间分配策略</center>

<p>在合并的过程中，链接器会把所有的目标文件的符号表收集起来，组成一个新的全局符号表，为后续的符号解析和重定位做准备。</p>
<p>将段合并之后，就可以得到各个符号在可执行文件的段中的位置（偏移）与分配的虚拟地址（VMA）了。</p>
<blockquote>
<p>这里讲一下虚拟地址（VMA）和加载地址（LMA）。</p>
<p>对于每一个进程，在操作系统（OS）中都有一个独立的假想的地址空间，我们称之为虚拟地址空间，虚拟地址空间可以起到隔离不同进程的作用。</p>
<p>现代的可执行文件中，使用的都是虚拟地址空间中的地址，在加载到物理内存的过程中，还需要经过一个地址转换的硬件模块（MMU），将虚拟地址转换为物理地址。</p>
<p>PS：如果没有MMU的支持，那么目标文件中的虚拟地址就等于物理地址。</p>
<p>加载地址，对于普通的PC机，即是把程序从硬盘中加载到内存中之后的地址，一般来说加载地址与虚拟地址是相同的（即加载到哪就在哪运行），除了嵌入式的特例（自行百度）。</p>
</blockquote>
<h4 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h4><p>所谓符号解析，就是查找合并后文件中的段中引用的全局符号的定义（即找到定义的虚拟地址），这个步骤依赖的是全局符号表。</p>
<p>重定位就是修正指令中引用符号的地址，利用的是重定位表，重定位表的每一项对应一个需要修正的位置的偏移（每一个需要重定位的地方叫做<strong>重定位入口</strong>），同时包含修正方法的类型以及该符号在符号表中的地址。</p>
<p>修正方法的类型总的可以分为<strong>绝对地址修正</strong>和<strong>相对地址修正</strong>两类。</p>
<p>以下是每个重定位入口对应的包含重定位需要的信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> offset;  	<span class="comment">// 需要被修改的引用的段偏移(重定位入口地址)</span></span><br><span class="line">    <span class="keyword">int</span> symbol:<span class="number">24</span>, 	<span class="comment">// 被修改的引用应指向的符号 </span></span><br><span class="line">        type:<span class="number">8</span>;   	<span class="comment">// 修改方式</span></span><br><span class="line">&#125;ELF32_REL;</span><br></pre></td></tr></table></figure>
<p>重定位段（表）的内容就是一个该数据结构的数组。</p>
<h3 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h3><p>静态库就是一系列编译好的还未链接的目标文件的集合（通过ar打包），一般是一个库函数对应一个目标文件，因为这样可以实现用到什么函数就链接什么函数，不会附带把不需要的函数链接到可执行文件中，从而节省了空间。</p>
<p>这里也有张图.jpg</p>
<h3 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h3><p>链接控制过程有两种方式：</p>
<ol>
<li>命令行参数式</li>
<li>链接脚本式</li>
</ol>
<p>链接脚本的方式灵活性很强，甚至可以自定义段名。在进行嵌入式或无操作系统的平台开始时，通常会用这种方式来控制可执行文件的段的分布，以满足硬件的要求。</p>
<h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><p>在链接之前的目标文件中，未初始化的全局变量会被标记为COMMON类型，且不会直接在<code>.bss</code>段中分配空间，为什么呢？</p>
<p>本质原因是链接器不能区分符号的类型，无法判断若符号的类型是否一致，导致弱符号的占用空间在链接前不能确定（强符号和弱符号那一节中讲过）。</p>
<h3 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h3><p>主要有两个问题：</p>
<ol>
<li>重复代码消除</li>
<li>全局对象的构造和析构</li>
</ol>
<h4 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h4><p>这里要消除的代码主要是由C++的模板机制、外部内联函数、虚函数表等造成的冗余。以模板为例，如果在不同的源代码文件（编译单元）中可能对同一个模板<code>add&lt;T&gt;()</code>进行了实例化，且实例化参数相同<code>add&lt;int&gt;()</code>，那么就会在不同目标文件中生成相同的实例化代码，如果直接合并的话，就会造成冗余。</p>
<p>解决的方法是对每一个实例化后的模板，将其单独存在在目标文件中的一个段中，这个段的名字是该实例化模板修饰后的名称（例如：<code>.temp.add&lt;int&gt;</code>），保证了唯一性，于是不同目标文件中的同一种实例化模板就能被检查出来，在合并的时候只需保留一个段就行。</p>
<p><strong>函数级链接</strong></p>
<p>函数级别链接，就是把每一个函数都单独地放到一个段里，链接器检测到用到了哪个函数就链接相应的段，没有用到的不会被链接到最终的文件里，与前面的静态库链接差不多。其目的也是为了减小最终的文件大小。</p>
<h4 id="全局对象的构造和析构"><a href="#全局对象的构造和析构" class="headerlink" title="全局对象的构造和析构"></a>全局对象的构造和析构</h4><p>在最终的可执行文件中，真正的程序入口是<code>_start</code>（Linux系统下），在这个函数中进行进程初始化工作，然后在其中调用<code>main</code>函数，进入到用户定义的主程序。全局类的构造就是在进入<code>main</code>之前这一段过程完成的，同样，其他基本类型的全局变量也是在这一段过程中完成初始化的。在<code>main</code>函数结束之后，会返回到<code>_start</code>中，进行一些清理工作（例如全局类的析构），然后再结束进程。</p>
<p>对此，ELF文件中有两个特殊的段：<code>.init</code>和<code>.fini</code>。在<code>.init</code>段中的代码，会在<code>main</code>函数之前执行，而在<code>.fini</code>段中的代码，会在<code>main</code>函数之后执行。</p>
<h3 id="ABI（Application-Binary-Interface）"><a href="#ABI（Application-Binary-Interface）" class="headerlink" title="ABI（Application Binary Interface）"></a>ABI（Application Binary Interface）</h3><p>API（Application Programming Interface）是源码级别的接口，而ABI是二进制级别的接口。</p>
<p>与ABI相关的东西有很多，具体包括：<strong>符号修饰标准，变量内存布局，函数调用方式等跟可执行文件二进制兼容性相关的内容。</strong>同时，机器的硬件平台、编程语言、编译器、链接器、操作系统等都会影响到ABI，所以，ABI的标准化一直是一个大问题。不同目标文件的ABI不同的话，就不能相互链接起来。</p>
<h3 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h3><p>BFD全称Binary File Descriptor library，是GNU的一个项目，目的是为了处理不同的目标文件格式。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>静态链接</tag>
        <tag>符号解析与重定位</tag>
        <tag>全局对象的构造和析构</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》第3章总结</title>
    <url>/2021/01/22/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC3%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>目标文件就是源代码经过编译后的，链接之前的文件，经过链接就变成了可执行文件，它也是一种二进制文件。</p>
<p>目标文件的格式其实与最终的可执行文件的格式是一致的，只是没有经过符号的链接过程。</p>
<p>在Windows环境下，可执行文件的格式是PE（Portable Executable），在Linux环境下，可执行文件的格式叫ELF（Executable Linkable Format），这两种格式差别不大，都是源自于COFF（Common File Format）格式的。</p>
<a id="more"></a>
<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>下面主要介绍一下ELF文件格式。</p>
<p>ELF文件下又可以分为4种类型：</p>
<ul>
<li><strong>可重定位文件（Relocatable File）</strong>，包含代码和数据，一般是指静态链接库文件。</li>
<li><strong>可执行文件（Executable File）</strong></li>
<li><strong>共享目标文件（Shared Object File）</strong>，也是一种可重定位文件，但是它可以被用于动态链接。</li>
<li><strong>核心转储文件（Core Dump File）</strong>，进程意外终止的时候，系统把进程地址空间的内容和一些其他信息存放到核心转储文件中，可以用于排除BUG。</li>
</ul>
<p>一个目标文件/可执行文件的基本组成部分都是段（Segment/Section），段就是把一个程序的不同部分分类存放，形成不同的段，一个目标文件最基本的段包括：</p>
<ul>
<li><strong>代码段（程序段）<code>.text</code></strong>，代码段就是存放程序的逻辑代码部分。</li>
<li><strong>数据段<code>.data</code></strong>，用于存放变量数据，但是这里存放的是<strong>已初始化</strong>的全局/静态变量。</li>
<li><strong>BSS（Block Started by Symbol）<code>.bss</code></strong>，BSS段则是为<strong>未初始化</strong>的全局变量和局部的静态变量，为他们预留位置，BSS段的起源是一个历史原因，同时也可以节省目标文件占用的空间。</li>
</ul>
<p>那么有人会问，那局部变量存放在哪呢？局部变量是存放在进程地址空间中的<strong>栈</strong>里，因为局部变量的生命周期是临时的一个函数调用期，而全局变量/静态变量的生命周期是整个程序运行期间，所以我们将全局/静态变量放在进程中单独的一个段里。</p>
<p><img src="/2021/01/22/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC3%E7%AB%A0%E6%80%BB%E7%BB%93/image-20210122183320332.png" alt="image-20210122183320332" style="zoom: 25%;"></p>
<center>目标文件的3个基础段</center>

<p>PS：段名都是以小数点<code>.</code>开头的。</p>
<p>同时，目标文件的最开始包含一个ELF文件头（ELF Header），它用来说明整个ELF文件各种信息，包括：是否可执行，是静态链接还是动态链接，入口地址（如果是可执行文件），目标硬件，以及<strong>段表（Section Header Table）</strong>的位置（文件位置偏移）等。这里的段表是一个重要的部分，它本质是一个数组，用来描述ELF文件中各个段的信息（名字、偏移and其他信息）。</p>
<p>目标文件中除了有各种“段”，还有各种“表”，上面说的段表就是一个，除此之外还有重定位表（Relocation Table）、字符串表（String Table）、符号表（Symbol Table）等等。每一个表也是通过段的形式存储在目标文件中的。</p>
<p><img src="/2021/01/22/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC3%E7%AB%A0%E6%80%BB%E7%BB%93/image-20210122181949194.png" alt="image-20210122181949194" style="zoom:25%;"></p>
<center>ELF文件结构</center>

<p>每一个需要重定位的段（例如代码段、数据段），都会有一个对应的重定位表，用来描述该段中需要重定位的引用的信息。</p>
<p>字符串表是将程序中所用到的变量名、段名等字符串集中起来放在一个段里，通过偏移量来表示字符串的。</p>
<p>符号表就是用来存放代码中用到的各种符号（函数名或变量名）的信息。符号一般分为全局符号、局部符号、段名、行号等。这里的全局符号（全局变量、非static函数）不仅包括定义在本文件中的全局符号，也包括引用其他文件中定义的全局符号，局部符号则是仅本文件内部可见的符号（主要是局部变量，还有static的变量和函数）。<strong>链接过程处理的就是全局符号</strong>。</p>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><h4 id="符号修饰问题"><a href="#符号修饰问题" class="headerlink" title="符号修饰问题"></a>符号修饰问题</h4><blockquote>
<p>一个讲的比较好的blog：<a href="https://www.cnblogs.com/wfwenchao/articles/4140388.html" target="_blank" rel="noopener">https://www.cnblogs.com/wfwenchao/articles/4140388.html</a></p>
</blockquote>
<p>在“远古时代”，编译后目标文件中的符号名与源代码中的符号名是一致的，随着软件工程的发展，就出现了一个问题：一个软件可能由多个人共同开发完成，如果他们没有对各自负责的模块中的变量、函数命名进行沟通及规范的话，很可能会造成符号重复的问题，即，不同模块中不同功能的函数名（或全局变量名）可能是一样的，或者是开发者写的函数名与所用到的库中的某一个函数撞名了，那么链接器在符号决议过程中就会冲突报错。</p>
<p>为了解决这个问题，现在的编译器一般会把源代码中的符号，经过一种修饰的规则修饰之后放入目标文件中，称为<strong>符号修饰（Name Decoration）或符号改编（Name Mangling）</strong>，不同的C++编译器对符号的修饰规则是不一样的（例如GNU的g++和微软的Visual C++编译器）。</p>
<p>有了符号修饰这个机制，就能很好地实现函数重载这类机制了，因为修饰机制一般会区分开同名函数的不同参数列表。同时，命名空间也是为了解决符号冲突而引入的一种机制。</p>
<p>一个函数对应一个唯一的<strong>函数签名（Function Signature）</strong>，函数签名包括了确定一个函数需要的所有信息，例如：函数名、参数列表、命名空间等。一个函数签名对应一个修饰后的符号名称（Decorated Name）。</p>
<p>由于C和C++的修饰规则并不一样，所以为了在C++程序中使用C的修饰规则，我们可以使用<code>extern &quot;C&quot;</code>这个关键字来声明符号，例如：<code>extern &quot;C&quot; double a;</code>，那么编译器就会对变量a使用C语言的修饰规则。</p>
<h4 id="强符号or弱符号、强引用or弱引用"><a href="#强符号or弱符号、强引用or弱引用" class="headerlink" title="强符号or弱符号、强引用or弱引用"></a>强符号or弱符号、强引用or弱引用</h4><blockquote>
<p>一个讲的比较好的blog：<a href="https://www.cnblogs.com/downey-blog/p/10470674.html" target="_blank" rel="noopener">https://www.cnblogs.com/downey-blog/p/10470674.html</a></p>
</blockquote>
<h5 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h5><p>强符号和弱符号是针对定义来说的，在C/C++语言中，已初始化的全局变量是一种强符号，未初始化的则是弱符号。在符号决议的过程中如果发现了多个同名的强符号<strong>定义</strong>，那么就会报错；如果有一个强符号定义以及一些弱符号定义，则不会报错，且强符号定义会覆盖弱符号定义；如果没有强符号定义，只有弱符号定义，那么会选择占用空间最大的那个（例如double类型比int型占用的字节大）。</p>
<p>我们也可以手动定义一个初始化的强符号，只需使用<code>__attribute__((weak))</code>关键字，例如：<code>__attribute__((weak)) int weak2 = 2;</code>，不过这样手动定义的弱符号不能和强符号共存。</p>
<p><strong>弱符号的一个用处是：在库中的定义是弱符号，用户可以重新定义一个自己使用的同名强符号，使得其覆盖库中版本，使用用户自定义版本的库函数的作用。</strong></p>
<h5 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h5><p>一般没有特殊声明的<strong>引用</strong>都是强引用，如果一个强引用在链接的符号决议过程中没有找到定义，链接器会报符号未定义的错误。而弱引用在没有找到定义时则不会报错，链接器会用0或者一个特殊的值代替。</p>
<p>将一个符号的引用声明为弱引用需要用到<code>__attribute__((weakref))</code>这个关键字，例如：<code>__attribute__((weakref)) foo()</code>，就是声明了一个名为foo的弱引用函数。当然，为了避免弱引用没有定义就使用，在使用前最好用if判断一下foo是否是0。</p>
<p><strong>弱引用一个重要的作用就是，使得程序的不同功能模块更容易地裁剪和组合。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>ELF文件格式</tag>
        <tag>段</tag>
        <tag>符号</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》第2章总结</title>
    <url>/2021/01/22/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC2%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>从源代码到可执行程序的整个过程，可以分为四步，分别是：<strong>预编译，编译，汇编，链接</strong>。</p>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译主要是处理代码中的预编译指令，预编译指令都是以<code>#</code>开头的，形如<code>#define</code>、<code>#include</code>、<code>#ifdef</code><strong>等</strong>，其中<code>#define</code>是直接文本替换；<code>#include</code>则是把include的文件直接复制到改行所在的位置；<code>#ifdef</code>是用来对部分代码是否需要编译进行控制的。长得像预编译指令的<code>#param</code>则会保留，因为这是给传递给编译器的指令。</p>
<p>PS：注释在预编译阶段会被全部删除。</p>
<a id="more"></a>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>狭义的编译就是将源代码翻译为汇编代码的过程，至于为什么说狭义，因为我们平常说的编译，一般包括了后面的汇编和链接过程。</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编就是把汇编语言转换为机器语言，这本质上是一个<strong>查字典</strong>的过程，因为每一条汇编语句都对应着唯一的机器码（不同ISA的CPU有着不同的字典）。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>在以前的单文件、小软件时代，由于符号（函数或变量）的定义和对它们的引用都是在同一个文件中，其地址很方便分配与确定，但是随着软件的大型化、模块化发展，一个软件的源代码文件有几十上百个（甚至上千上万），它们生成的目标文件也有几十上百个。在它们之间，符号定义和其引用关系很复杂，一个文件中定义的符号很可能被其他文件所引用，且文件之间存在相互引用，于是导致不能在编译阶段确定符号的地址，只能采用临时地址来暂时替代最终的实际地址。</p>
<p>具体的符号的地址在最后一步——链接过程完成，链接细致一点又可以分为<strong>地址和空间的分配，符号决议，重定位</strong>，这三个步骤。其中第一个过程看名字就很好理解；第二个过程则是链接器检查所有的目标文件中每一个符号的引用，确保它们有且仅有有唯一的定义；第三个过程则是对目标文件中不能确定的临时地址的修正，将其修改为分配完地址后的地址。</p>
<h3 id="编译器的流程"><a href="#编译器的流程" class="headerlink" title="编译器的流程"></a>编译器的流程</h3><p>现代编译器通常集成了上述四个功能。我们现在以编译一个单一源代码文件的流程来进一步分析编译的背后流程，主要分为6个步骤：词法分析，语法分析，语义分析，中间语言生成，目标代码生成，目标代码优化。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析是将源代码输入到一个扫描器中，得到的结果是对代码中各种符号的识别分类，这里的符号包括：关键字，标识符，字面常量运算符等。为后续的语法分析奠定基础。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析是检查你所写的代码是否符合语言的语法￼规定。</p>
<p>它利用词法分析得到的记号来生成语法树。语法树就是你此法分析中得到的各种为节点的、按照你所写的代码的表达式来组织的一种树状数据结构。这里的语义分析并<strong>没有确定</strong>各种记号的<strong>具体</strong>类别，例如变量a的类型到底是int还是float，只知道它是一个变量，假如有一句<code>b=array[a];</code>，<strong>即使a实际是float类型，但是在语法分析阶段还是不会报错</strong>，因为这一句满足变量作为下标这一个语法，这里检查出来有错误是下一步——语义分析的工作。</p>
<p>一个语法树的例子，以下是表达式<code>a=(b+4)*c;</code>的语法树：</p>
<p><img src="/2021/01/22/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E7%AC%AC2%E7%AB%A0%E6%80%BB%E7%BB%93/image-20210120204442258.png" alt="image-20210120204442258" style="zoom:25%;"></p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>语义分析是检查你所写的代码表达式是否是具有正确的意义，例如你把一个浮点数用作数组的下标，这在语法上是正确的，因为满足下表示一个标识符这个语法，但是这种写法并没有正确的含义，因为数组的下标是不能用浮点数表示的。</p>
<h4 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h4><p>中间语言生成是将源代码转换为一种，便于优化的表现形式（中间语言），一般有可以转为三地址码，P-代码等。并在这个过程中对代码进行一次优化。由于是从源码转换过来的，所以又称源码级优化。</p>
<h4 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h4><p>中间语言生成之后就进入到了<strong>编译器后端</strong>流程。其就是将中间语言代码转换为最终目标机器平台的机器语言代码（也就是0、1组成的bit流），同时进行优化。其实这个过程就包括了之前所说的汇编过程。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《程序员的自我修养》</category>
      </categories>
      <tags>
        <tag>《程序员的自我修养》</tag>
        <tag>编译</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>一个神奇的c语言程序</title>
    <url>/2020/12/10/%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>更新：问题已解决，详见<a href="https://zhuanlan.zhihu.com/p/335669734" target="_blank" rel="noopener">一个神奇的C语言程序 - 知乎 (zhihu.com)</a>评论区大佬。（果然还是太菜了……</p>
<p>写代码时为了节省空间，就是用了uint8_t，然后发现一个很神奇的现象，程序很简单，但是现象很神奇：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> a = <span class="number">123</span>, b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scanf("%d", &amp;a);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 15</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, 15</span><br></pre></td></tr></table></figure>
<p>可以看到，对于变量a，不仅没有成功输入，并且初始化的123也没了。</p>
<p>很神奇。。。</p>
<p>同时，如果只输入一个a，是可以正常读入到a中的，读入a和b就不行，即使用两个scanf分开来读。</p>
<p>个人猜测与uint8_t这个类型本身其实是unsigned char类型，以及scanf的%d读入有关（但是感觉用%d读入char型也没毛病呀。。。毕竟单独输入a就可以正常读入。</p>
<p>暂时做一个记录，以后有时间深入研究。</p>
<p>如果有大佬知道是什么原理，请在评论留言！</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>uint8_t</tag>
        <tag>日常迷惑</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++变长参数及64位机器未指定整数类型的情况</title>
    <url>/2020/11/07/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%8F%8A64%E4%BD%8D%E6%9C%BA%E5%99%A8%E6%9C%AA%E6%8C%87%E5%AE%9A%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>记2020.11.7</p>
<p>在看《程序员的自我修养 ——链接、装载与库》第11章的时候，看到了C语言变长参数的实现，于是按照它给的例程写了一个测试程序：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;num+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*p));</span><br><span class="line">        sum+=(*p);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">53</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">16</span><br><span class="line">0</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>显然，不符合预期（预期是三个参数的和107）。</p>
<p>那么，这是为什么呢？跟据变长指令实现的原理（_cdecl调用惯例和栈的利用），猜测是由于我是64位的CPU（书中作者的CPU是32位），所以每次PUSH送入栈的数据位宽大小是64位，而int类型应该是32位的，指针一次只增加和读取4个字节，于是我将main函数中调用的第一个num的参数值改为6。再次运行，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">16</span><br><span class="line">0</span><br><span class="line">38</span><br><span class="line">0</span><br><span class="line">53</span><br><span class="line">107</span><br></pre></td></tr></table></figure>
<p>结果正确。猜测正确，同时也可以看出来我的CPU是大端模式。</p>
<p>为了使功能正确（num的值等于参数的数量），于是考虑把int类型改为long，谁知还是一样的结果。</p>
<p>经过@AgNo3的提醒，<strong>C语言中int、long这些基本整型变量的位宽没有确定的标准</strong>，也就是不同编译器给这些数据类型的位宽不一定一样。如果想要指定确定的位宽，只能使用头文件<code>stdint.h</code>中的int8_t，int_16_t、int32_t、uint8_t……这些类型（见<a href="https://www.gnu.org/software/libc/manual/html_node/Integers.html）。" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Integers.html）。</a></p>
<p>于是将所有的int类型改为int64_t，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br><span class="line">38</span><br><span class="line">53</span><br><span class="line">107</span><br></pre></td></tr></table></figure>
<p>结果正确。</p>
<p>同时还可以<strong>猜测</strong>，C程序在使用没有指定类型的整型常量（字面值）时，默认是使用与CPU字长相同的宽度。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>变长参数</tag>
        <tag>整型数据宽度</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2移植经历（一）</title>
    <url>/2020/11/02/ORB-SLAM2%E7%A7%BB%E6%A4%8D%E7%BB%8F%E5%8E%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>移植内容是将修改版的ORB-SLAM2工程移植到ARM+DSP（FPGA实现）系统上。</p>
<p>项目来源于导师（苦逼的打工人/(ㄒoㄒ)/~~），由于该项目涉及到公司商业信息，我只是讲述有关移植部分的通用经历。</p>
<a id="more"></a>
<h2 id="一、环境搭建与安装"><a href="#一、环境搭建与安装" class="headerlink" title="一、环境搭建与安装"></a>一、环境搭建与安装</h2><p>因为我之前已经在笔记本上安装了Ubuntu20.04，所以一上来，我就不管三七二十一，直接在网上搜索ORB-SLAM2的安装与运行教程，找到一个后，跟着步骤来。</p>
<p>在安装opencv的时候，一开始选择的是3.4.12，结果中途报错（错误及解决方法见：<a href="https://stackoverflow.com/questions/46884682/error-in-building-opencv-with-ffmpeg），个人猜测与opencv版本与gcc版本有关（后面会提到）。" target="_blank" rel="noopener">https://stackoverflow.com/questions/46884682/error-in-building-opencv-with-ffmpeg），个人猜测与opencv版本与gcc版本有关（后面会提到）。</a></p>
<p>解决opencv的安装后，我直接就在发来的原工程里运行<code>./build.sh</code>，编译过程中也遇到了一个问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;include&#x2F;c++&#x2F;9&#x2F;bits&#x2F;stl_map.h:122:71: error: static assertion failed: std::map must have the same value_type as its allocator</span><br><span class="line">  122 |       static_assert(is_same&lt;typename _Alloc::value_type, value_type&gt;::value</span><br></pre></td></tr></table></figure>
<p>经过查询，需要改一下源码中一个头文件的typedef内容（<a href="https://blog.csdn.net/lixujie666/article/details/90023059），同样，这个问题显然也与gcc版本有关（因为他们发给我的东西肯定都是测试能跑通的，可惜当时我没有意识到gcc版本的问题）。" target="_blank" rel="noopener">https://blog.csdn.net/lixujie666/article/details/90023059），同样，这个问题显然也与gcc版本有关（因为他们发给我的东西肯定都是测试能跑通的，可惜当时我没有意识到gcc版本的问题）。</a></p>
<p>编译好后，想都没想，直接运行Examples中的Monocular例子，报找不到动态链接库xxx的问题，于是经过搜索，了解到了<code>ld.so.conf</code>、<code>ld.so.conf.d</code>、<code>ldconfig</code>和<code>ldd</code>这些东西，是用于管理Linux下的动态链接库的。参考链接如下：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/98027a1f014d" target="_blank" rel="noopener">https://www.jianshu.com/p/98027a1f014d</a></p>
<p><a href="https://www.cnblogs.com/lyongde/p/4190588.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyongde/p/4190588.html</a></p>
</blockquote>
<p>但是修改过后，反复尝试编译了很多遍，Monocular中的例子仍然报错。。。许久之后，绝望之中决定查看CMakeLists.txt的内容，看看是否没有添加相关的库。结果一看就发现了问题所在——原来是因为这个CMakeLists.txt被他们的工程师给修改过了，只产生RGB-D中的可执行文件。。。</p>
<p><strong>于是得到第一条经验：在接收别人修改过的工程后，最好先看看CMakeLists.txt中的内容</strong>。</p>
<p>于是运行RGB-D中的例子，仍然报错，并且是找不到DBoW2和g2o两个动态链接库，我寻思这不是自带的吗？build.sh中也有相关的编译过程。于是再次编译整个过程，仔细查看发现问题：新建build文件夹失败，文件夹已存在，balabala……</p>
<p>原来是原来编译的东西没有删除。。。</p>
<p><strong>于是得到第二条经验：重新编译工程的时候最好把原来编译的残留文件都删除</strong>。</p>
<p>删除之后再次重新编译运行，这次终于成功运行了程序，激动不已，但是几秒后，程序就结束了运行——opencv报错。经过各种搜索，都没有找到ORB-SLAM2遇到过这种问题的。于是想是不是opencv版本的问题？经过询问，他们使用的是opencv3.4.9，于是重新安装 ，但是结果还是一样/(ㄒoㄒ)/~~</p>
<p>怀着近乎崩溃的心情，把这个错误截下来，发给了他们的工程师，得到的一个重要信息是，他们使用的 ubuntu版本是16.04，同时gcc版本与我的不同，他们建议我安装16.04版本。</p>
<p>但是作为经历过许多次重装系统的我，不想再经历一次了（重装系统本身不麻烦，麻烦的是重装后的软件安装、环境配置）。。。</p>
<p>于是把希望放在gcc的版本上，查询到16.04的默认gcc大版本为5，而20.04的是9.3版本，差距有点大(lll￢ω￢)。。。直接<code>apt get install gcc-5</code>是不成功的，因为20版本的软件源里没有版本5（最低的貌似是7），于是查询ubuntu gcc降级及多版本共存的方法（<a href="https://blog.csdn.net/EternallyAccompany/article/details/108865331），原理就是添加16.04的源（所以可以换成16.04的国内源），然后更新、安装" target="_blank" rel="noopener">https://blog.csdn.net/EternallyAccompany/article/details/108865331），原理就是添加16.04的源（所以可以换成16.04的国内源），然后更新、安装</a> 。</p>
<p>安装后得到5.3.1的gcc和g++，重新编译、运行工程，功夫不负有心人，最终成功运行！！！</p>
<p><strong>于是得到第三条经验：对于C++项目来说，GCC、G++的版本很重要！</strong>因为C++的复杂机制与杂乱的标准，导致不同版本的编译器编译同一个项目时，结果可能会不一样（比如一个 通过，另一个报错），这也是C++广遭吐槽的一点。</p>
<p>同时，<strong>总结出第四条经验：要积极主动地与他人沟通，接收项目时一定要事先询问好搭建的环境（系统、编译器版本和环境），不要害羞</strong>。</p>
<p>未完待续…..</p>
]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>打工人的日常</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
        <tag>移植</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32与PC机的大小端一致性问题</title>
    <url>/2020/10/28/stm32%E4%B8%8EPC%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记2020.10.28</p>
<p>今天心血来潮想把上学期末计划做的用STM32在LCD上播放Bad Apple，需要用到的东西包括：FatFs文件系统、LCD显示驱动，以及视频转二进制文件的工具。</p>
<a id="more"></a>
<p>FatFs及LCD驱动都是直接拿教程的源代码改的（毕竟我懒，and时间也有限……），视频转二进制的工具是我上学期末写的一个脚本（Github：<a href="https://github.com/Floral/MyGadgets），今天遇到的问题主要就是跟这个脚本及LCD显示的程序有关。" target="_blank" rel="noopener">https://github.com/Floral/MyGadgets），今天遇到的问题主要就是跟这个脚本及LCD显示的程序有关。</a></p>
<p>这个脚本目前只支持黑白视频的转换（毕竟是是根据Bad Apple来写的嘛），并且我在今天发现了一个问题，就是python的二进制写入文件模式是以字节为单位的，即假设一个bool数组只有一个True，我原本想的是写入后文件只含有一位二进制，而实际是这个bool被扩展为了一个字节，最终的结果就是0x01（想想也是，毕竟所有的汇编语言的读写最小单位都是byte，而不是bit）。所以该脚本目前的版本中生成的结果bin文件中也是按照一个像素对应一个字节的，在嵌入式程序中，显示控制程序也很简单，一个byte用来决定一个像素的值。<strong>这种方案的实验结果很成功</strong>，让我开心了一小会儿，可惜快乐总是短暂的。</p>
<p>由于这个视频只是一个黑白视频，所以一个像素所需要的位数并不要一个字节，一位就够了，可以节省大量空间。于是强迫症的我一下午的时间就花在了怎么按位写入。查阅资料后得到的结论是，并不能按位写入，只能通过转换的手段，一组一组地把八位转换为一个byte再写入。</p>
<p>改好脚本后，本以为大功告成，上板子一实验，问题大了，画面纵向割裂，分成10列（整体是80×60像素），仔细观察，造成这一现象的原因是某些列被“镜像”了（如图），由程序中的显示流程大致可以判断，这个错误与生成的bin文件的大小端存储方式、STM32读取文件的大小端存储方式以及STM32的C语言中一个字节中访问LSB和MSB的先后有关。</p>
<p><img src="/2020/10/28/stm32%E4%B8%8EPC%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/image-20201107232739129.png" alt="image-20201107232739129" style="zoom: 50%;"></p>
<p><img src="/2020/10/28/stm32%E4%B8%8EPC%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/image-20201107232802323.png" alt="image-20201107232802323" style="zoom:50%;"></p>
<p><img src="/2020/10/28/stm32%E4%B8%8EPC%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/image-20201107232815642.png" alt="image-20201107232815642" style="zoom:50%;"></p>
<p><img src="/2020/10/28/stm32%E4%B8%8EPC%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/image-20201107232828944.png" alt="image-20201107232828944" style="zoom:50%;"></p>
<p>经过多次检查及修改测试，发现python脚本生成过程并没有问题，于是针对c语言程序进行排查，尝试了几种大小端读取的组合后，还是没有解决，甚至怀疑是不是STM32的程序中途错乱了（毕竟有跑飞的可能）。一晃时间就到了晚上九点多。。。一天其他啥事都没干，于是决定把这个问题暂时放下，先记录下这个现象，等待以后或许某一天再跑的时候能奇迹般地正常！或者有时间系统地测试一下问题。</p>
<p>不过这次经历也提醒了我，<strong>在用不同平台或不同语言读写二进制文件的时候，需要格外注意大小端的字节序和一个字节中的比特序</strong>。</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>字节序</tag>
        <tag>比特序</tag>
        <tag>大小端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于常量不加位数限制的坑</title>
    <url>/2020/10/25/%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%8A%A0%E4%BD%8D%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>遇坑代码如下：</p>
<a id="more"></a>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> freq_div(</span><br><span class="line">    <span class="keyword">input</span> clk_i,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> clk_o</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> CNT_MAX = <span class="number">25000</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">12</span>:<span class="number">0</span>] clk_cnt = <span class="number">13'b0</span>;</span><br><span class="line">    <span class="keyword">reg</span> clk_o_reg = <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_o = clk_o_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_i) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (clk_cnt == CNT_MAX) <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= <span class="number">13'b0</span>;</span><br><span class="line">                clk_o_reg &lt;= ~clk_o_reg;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= clk_cnt + <span class="number">1'b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_cnt &lt;= clk_cnt;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>综合后的结果如下：</p>
<p><img src="/2020/10/25/%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%8A%A0%E4%BD%8D%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E5%9D%91/image-20201023001837809.png" alt="image-20201023001837809" style="zoom:50%;"></p>
<p>于是这个错误导致了动态数码管显示只显示了最低位的数码管。（但是由于Vivado并没有提示这个模块有任何报错or Warning，所以我一直没有注意到freq_div综合后的结果，一直去看该错误导致的另一个出现Warning的模块了）</p>
<p>导致综合并没有提示Error/Warning的罪魁祸首就是第8行的<code>parameter CNT_MAX = 25000 -1</code>。而本质错误是由于我的<code>clk_cnt</code>位数设置错误，因为24999已经超过了13位的最大范围。如果将第8行改为<code>parameter CNT_MAX = 13&#39;d25000 -1</code>，那么综合后会产生常数因超过最大值而被截断的Warning（如下图），于是就能马上发现错误而改正。</p>
<p><img src="/2020/10/25/%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%8A%A0%E4%BD%8D%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E5%9D%91/image-20201023003048134.png" alt="image-20201023003048134" style="zoom:50%;"></p>
<p>将<code>clk_cnt</code>的位数改为32位，并将第8行改为<code>parameter CNT_MAX = 32&#39;d25000 -1</code>，之后综合结果正常，如下：</p>
<p><img src="/2020/10/25/%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%8A%A0%E4%BD%8D%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E5%9D%91/image-20201023002502559.png" alt="image-20201023002502559"></p>
<blockquote>
<p> <strong>通过本次血泪史学到的教训——常数一定也要加位数限制，不要为了图方便而不写位数！</strong>同时写之前也要计算好常数的位数！</p>
</blockquote>
]]></content>
      <categories>
        <category>硬件</category>
        <category>FPGA踩坑记录</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>位宽</tag>
      </tags>
  </entry>
  <entry>
    <title>关于异步复位的错误写法导致的问题</title>
    <url>/2020/10/25/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E7%9A%84%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这是一个异步复位的错误写法引发的血案</p>
<a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>2020.10.20晚：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> freq_div(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> en,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_o</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] clk_cnt = <span class="number">32'b0</span>; <span class="comment">//clk的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (clk_cnt == (<span class="number">25000000</span> - <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">                    clk_cnt &lt;= <span class="number">32'b0</span>; </span><br><span class="line">                    clk_o &lt;= ~clk_o;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_cnt &lt;= clk_cnt+<span class="number">1</span>;  </span><br><span class="line">                    clk_o &lt;= clk_o;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= clk_cnt;</span><br><span class="line">                clk_o  &lt;= clk_o;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            clk_o  &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>综合后有如下警告：</p>
<p><img src="/2020/10/25/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E7%9A%84%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/image-20201020232826101.png" alt="image-20201020232826101"></p>
<p>其中37行就是<code>if (clk_cnt == (25000000 - 1)) begin</code>这一行（因为前面有一部分文件头没有放上来）。</p>
<p>一个比较坑的地方就是，行为仿真的时候并没有什么问题，但是下载后，在板子上的现象出错。</p>
<p>如果去掉rst_n信号，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> freq_div(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> en,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_o</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] clk_cnt = <span class="number">32'b0</span>; <span class="comment">//clk的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (clk_cnt == (<span class="number">25000000</span> - <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= <span class="number">32'b0</span>; </span><br><span class="line">                clk_o &lt;= ~clk_o;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= clk_cnt+<span class="number">1</span>;  </span><br><span class="line">                clk_o &lt;= clk_o;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_cnt &lt;= clk_cnt;</span><br><span class="line">            clk_o  &lt;= clk_o;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>综合就没有问题，板子上的效果也正常。</p>
<p>有点迷惑，先记下。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>2020.10.21上午：</p>
<p>这是一个很傻x的问题，本质是我把软件的编程思路也带进来了：在含有rst_n的代码中，由于always模块的敏感信号是rst_n的下降沿，当rst_n产生下降沿的时候，立即进入always块，此时rst_n肯定是低电平，因为是下降沿触发的，所以电路肯定执行的是else部分的逻辑，这就相当于rst_n信号每次下降沿时，总是复位状态，并不能进入到前半部分的if中，所以clk_cnt在综合时被vivado给优化掉了（至于有人想问：clk触发时如果rst_n为高电平时不是可以进入if吗？并且仿真的时候也没有问题呀？为什么还会被优化？——emmm这个问题我也挺想问的……具体应该与vivado的仿真及综合算法有关）。</p>
<p>解决问题的方法就是把if的条件换成<code>!rst_n</code>，然后把if和else中的内容交换一下位置就行了（具体如下）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> freq_div(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> en,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_o</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] clk_cnt = <span class="number">32'b0</span>; <span class="comment">//clk的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">            clk_cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            clk_o  &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (clk_cnt == (<span class="number">25000000</span> - <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">                    clk_cnt &lt;= <span class="number">32'b0</span>; </span><br><span class="line">                    clk_o &lt;= ~clk_o;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_cnt &lt;= clk_cnt+<span class="number">1</span>;  </span><br><span class="line">                    clk_o &lt;= clk_o;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                clk_cnt &lt;= clk_cnt;</span><br><span class="line">                clk_o  &lt;= clk_o;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>所以，以后一定要注意，always块在涉及到边沿触发的信号时，块中的判断条件一定要写成满足触发沿后的状态的样子。</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>FPGA踩坑记录</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>异步复位</tag>
      </tags>
  </entry>
  <entry>
    <title>《线性代数的本质》笔记</title>
    <url>/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<blockquote>
<p>课程地址：<a href="https://www.bilibili.com/video/BV1ys411472E" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ys411472E</a></p>
<p>这个链接跳转有谜之问题，建议手动复制到地址栏</p>
</blockquote>
<h2 id="01-什么是向量"><a href="#01-什么是向量" class="headerlink" title="01 什么是向量"></a>01 什么是向量</h2><p>向量在不同专业的人眼里有不同的看法：</p>
<p>在物理学的学生眼里，向量是一个空间中的箭头，决定它的是这个箭头的长短和方向，它的位置可以是任意的。</p>
<p>在计算机的学生眼里，向量是一个“列表”（即向量的代数表达），该列表可以有不同的行和列，同时每一个位置的值对应的物理意义都是一定的，不能交换位置。</p>
<p>在数学家眼里，向量可以是以上两种中任何一种表达（也可以是其他很多事物的表达），这两者其实是相互关联的。</p>
<a id="more"></a>
<p>后面的讲解都是把向量看作一个坐标系中，以原点为起点的箭头，这个箭头与一对数（一个“列表”，向量坐标）唯一对应。通常是竖着写的向量，在二维坐标系中，列表（向量）中的第一个数代表向量箭头终点在x轴方向上的偏移，第二个数代表向量箭头终点在y轴方向上的偏移。</p>
<p>这对数的值同时也是该向量箭头终点的坐标。</p>
<p>向量有两个重要的运算：<strong>向量加法</strong>和<strong>向量数乘</strong>。后续的内容 基本上都是围绕这两种运算展开的。</p>
<p>向量加法就是把第二个向量的起点移动到第一个向量的终点，然后由第一个向量的起点（原点）指向第二个向量的终点，构成一个新的向量，代数的表达就是向量对应位置的数值直接相加。</p>
<p>向量的数乘在几何方面就是对箭头长度的缩放（scaling），负号代表方向取反。在代数方面就是乘数（标量scalars）与向量对应位置的数值相乘的结果。</p>
<h2 id="02-线性组合、张成的空间与基向量"><a href="#02-线性组合、张成的空间与基向量" class="headerlink" title="02 线性组合、张成的空间与基向量"></a>02 线性组合、张成的空间与基向量</h2><p>首先谈谈线性组合，什么是线性组合，这里我们定义<strong>两个向量数乘后的向量和即为线性组合</strong>，形如 $ a\vec i+b\vec j$的式子（三维形式则再加一个向量$\vec k$，更高维的以此类推）。然后我们看一个向量的代数表达，这时我们可以将两个数的值（x和y）看作两个向量（x轴方向上的单位向量$\vec i$和y轴方向上的单位向量$\vec j$）的缩放（数乘的值），那么这个向量就可以被表示为$ x\vec i+y\vec j$。</p>
<p>我们将可以将$\vec i$和$\vec j$称为一对<strong>基向量</strong>。二维平面中的任意一个向量都能表示为这两个<strong>基向量的线性组合</strong>。同时我们将能够由基向量的线性组合而得到的<strong>向量的集合</strong>称为这一对向量所<strong>张成的空间（span）</strong>（或者说是向量空间？）。</p>
<p>同理，三维空间中也存在三个基向量，它们的span就是整个三维空间。</p>
<p>同时，一个平面的基向量并不是唯一的一对，它可以有多对不同的组合（只要他们不共线/至少一个为零向量）。因为共线/包含零向量的一对向量他们的线性组合并不是整个平面，而是一条线或者一个点。</p>
<p>在学线性代数的时候老师讲过一个概念：线性相关和线性无关。当一组向量中，存在某一个向量能被其他向量<strong>线性表示</strong>（即能被表示为其他向量的线性组合），那么我们就说这一组向量<strong>线性相关</strong>。换一种说法就是这个向量对这一组其他向量张成的空间没有任何贡献，它是多余的，因为它能被分解为其他的向量的线性组合。上一段中所说的共线/包含零向量的情况就是线性相关的情况。反之，若一组向量互相都不能线性表示，则成为<strong>线性无关</strong>（向量组）。</p>
<p>再回到开头 ，什么样的向量可以称为基向量呢？在了解线性相关和线性无关后，我们可以说，<strong>一个向量空间的一组基是张成该空间的一组线性无关的向量集。</strong></p>
<h2 id="03-矩阵与线性变换"><a href="#03-矩阵与线性变换" class="headerlink" title="03 矩阵与线性变换"></a>03 矩阵与线性变换</h2><p>什么是变换，就是给定一个输入，它会给出一个变换后的输出，这与函数的定义几乎一致。</p>
<p>线性变换的要求：</p>
<ul>
<li>所有的直线变换后仍是直线</li>
<li>原点保持不变</li>
</ul>
<p>正是由于这两个特性，当一个向量以及能表示它的基向量<strong>都经历变换</strong>这个过程之后，它们之间的<strong>线性关系保持不变</strong>，即该向量被基向量表示的<strong>数乘系数不变</strong>。于是，我们只需要知道一个空间的一组基向量变换后的向量值，就能求得该空间中其他任一向量变换后的值。</p>
<p>我们将一组<strong>变换后的基向量</strong>（2×1）按列组合起来（以二维平面中的基向量为例），即构成了一个2×2的<strong>矩阵</strong>。这个矩阵就可以成为描述这个变换的工具，我们将变换的过程表示为该矩阵与一个特定向量的乘积（矩阵左乘向量），得到的结果就是该向量变换后的坐标。如下图：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200926163609382.png" alt="image-20200926163609382" style="zoom: 50%;"></p>
<p>所以，<strong>任何一个矩阵都可以看做一个特定的线性变换，而矩阵与向量的乘积，则表示线性变换的过程，其结果表示向量变换后的结果。</strong></p>
<blockquote>
<p>PS：这里向量变换前后的坐标值都是相对于同一个坐标系来讲的，只有这样两个坐标的比较才能有意义。一般讨论中都是相对原坐标系（笛卡尔坐标系）来说的。</p>
</blockquote>
<h2 id="04-矩阵乘法与线性变换复合"><a href="#04-矩阵乘法与线性变换复合" class="headerlink" title="04 矩阵乘法与线性变换复合"></a>04 矩阵乘法与线性变换复合</h2><p>由上一节可知，一个矩阵对应一种线性变换，一个矩阵与一个向量相乘则对应对该向量进行一种线性变换，结果得到变换后的向量。如果再次用另一个矩阵与该向量相乘，则又会得到原向量进行第二次变换后的向量。如果我们不写中间第一次变换后的结果，把两次变换连起来写，那么就得到两个矩阵相乘的形式（如下图等式左侧）。我们可以找到直接用一个变换就能使原向量变为最终向量的变换（复合矩阵），于是有理由相信，左侧的两个矩阵相乘的结果就是复合矩阵（这一点也很容易由我们线性代数课上学的计算法则证明，或者通过变换的几何概念也很容易证明），于是我们可以得到矩阵相乘的结合律了：$(AB)C=A(BC)$。这一个性质也很容易由直觉得到，因为括号并不影响进行线性变换的顺序。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200926170506213.png" alt="image-20200926170506213" style="zoom:50%;"></p>
<p>不过值得注意的是，矩阵相乘并没有交换律：$AB\neq BA$，这很容易通过举例证明 （上图中的例子就行）。</p>
<h2 id="附1-三维空间中的线性变换"><a href="#附1-三维空间中的线性变换" class="headerlink" title="附1 三维空间中的线性变换"></a>附1 三维空间中的线性变换</h2><p>三维空间中的线性变换就是二维空间线性变换的扩展，即每一个基向量变成了一个3维向量，变换的矩阵也变成了3×3的矩阵，其他概念可类推。</p>
<h2 id="05-行列式"><a href="#05-行列式" class="headerlink" title="05 行列式"></a>05 行列式</h2><p>行列式（determinant）的几何意义就是一块区域在经过该矩阵所表示的线性变换后，得到的新的区域的面积与原区域面积的比例（也可以看作单位正方形经过变换后的平行四边形的面积，即该矩阵的两个向量所构成平行四边形的面积）。</p>
<blockquote>
<p>PS：这里的面积是在二维平面的条件下讨论的，对于三维空间来说则是体积。</p>
</blockquote>
<p>具体的证明可以通过几何画图来证明：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200926195633637.png" alt="image-20200926195633637" style="zoom:50%;"></p>
<p>有了这个结论，我们很容易就知道，为什么<strong>行列式为0的矩阵中的向量组一定线性相关</strong>了。因为变换后的两个向量是共线/至少有一个为零向量的（二维平面范围内）。</p>
<p>还有一点需要注意的是，行列式是有负值的，在二维平面中，负号所代表的意义是平面的翻转（这一点与通量很类似）；在三维空间中，负号所代表的是左手系和右手系之间的转换。但是行列式的绝对值的意义还是变换后面积/体积的缩放比例。</p>
<h2 id="06-逆矩阵、列空间、秩与零空间"><a href="#06-逆矩阵、列空间、秩与零空间" class="headerlink" title="06 逆矩阵、列空间、秩与零空间"></a>06 逆矩阵、列空间、秩与零空间</h2><p>矩阵的一个用处是用来解线性方程组的，形如：$A\vec x=\vec v$，其中变换矩阵$A$和变换后的向量$\vec v$已知，我们需要求变换前的向量$\vec x$。由几何意义可知，只要该变换不是将原向量空间压缩成更低维度的向量空间，即<strong>det(A)不等于0</strong>，那么我们<strong>就能唯一确定一个逆变换$A^{-1}$使得$\vec v$能还原为$\vec x$</strong>，该方程就有唯一解，否则（det(A)=0）为无穷解（或无解）。</p>
<p>$A^{-1}$和$A$的乘积为单位矩阵E，于是可得$\vec x=A^{-1}\vec v$，即求得了$\vec x$。</p>
<p>列空间就是<strong>矩阵的列向量所张成的空间</strong>。</p>
<p>秩的概念就是矩阵所表示的线性变换后的空间维度，或者说是列空间的维度。例如一个3×3的矩阵所表示的线性变换会把任何三维向量压缩到一个二维平面里，那么就说这个矩阵的秩为2，同时这个矩阵的列向量所张成的空间为一个二维平面，同时该矩阵的行列式为0。</p>
<p>如果一个经过矩阵变换前后的维度没有改变，我们把这种情况称为满秩，<strong>满秩矩阵</strong>的齐次方程的解（$Ax=\vec 0$）只有一个（只有0向量能变换为0向量），一个<strong>非满秩矩阵的变换</strong>的齐次方程的解就有无穷个了，因为有许多向量可以经过变换变为0向量，这些<strong>经过变换后落到零点的向量的集合被称为零空间/核</strong>。</p>
<h2 id="附2-非方阵"><a href="#附2-非方阵" class="headerlink" title="附2 非方阵"></a>附2 非方阵</h2><p>我们之前讨论的都是方阵，即向量数与向量维度相等，当两者不等时则称非方阵。</p>
<p>若有一个矩阵是3×2，我们可以将它看成是一个将二维平面映射到三维空间中的一个二维平面的变换，听起来有点绕，意思就是把单纯的一个平面映射为空间中的一个平面，使它的基向量变为有三个维度的向量。</p>
<p>若一个矩阵是1×2，则可以看成是将一个二维平面映射到一个一维的线上的变换，即减小了基向量一个维度。</p>
<h2 id="07-点积与对偶性"><a href="#07-点积与对偶性" class="headerlink" title="07 点积与对偶性"></a>07 点积与对偶性</h2><p>点积的标准计算方式就是按照向量中对应位置的坐标相乘再相加。点积的几何意义是点积的大小等于一个向量$\vec x$在另一个向量$\vec y$上的投影的长度与$\vec y$的长度的乘积，点积的正负号取决于$\vec x$投影后的向量与$\vec y$的方向是否相反，若相反，则为负，否则为正。这个投影的过程可以交换，即也可看作$\vec y$向$\vec x$的投影。</p>
<p>现假设一个向量单位$\vec u$，横纵坐标分别为$u_x$和$u_y$，再假设一个变换为把其他向量都投影到该向量所在直线上，那么这个变换的矩阵是什么呢？跟据对偶性可知（见下图，详见视频），该变换矩阵就是$[u_x, u_y]$，所以要求其他向量经过改变换得到的值时，直接用$[u_x, u_y]$与所需变化向量$\vec v$相乘即可，由线性代数所学的运算法则可得结果是一个数，即投影后在那条直线上的长度。这个相乘的过程与我们的点积定义形式惊人的一致，于是，如果我们把$\vec v$与$\vec u$的点积的计算过程就可以看作求$\vec v$向$\vec u$所在直线投影与$\vec u$的长度相乘的过程（包括符号）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200927090916490.png" alt="image-20200927090916490" style="zoom:50%;"></p>
<p>从数学式子来看，如果我们相求两个列向量$\vec u$和$\vec v$的的点积$\vec u \cdot\vec v$，我们可以<strong>把前者转换成一个线性变换的矩阵与后者相乘</strong>，那么式子的<strong>几何意义就变成了求$\vec v$向$\vec u$投影与$\vec u$的大小的积</strong>。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200927090744950.png" alt="image-20200927090744950" style="zoom:50%;"></p>
<h2 id="08-叉积"><a href="#08-叉积" class="headerlink" title="08    叉积"></a>08    叉积</h2><p>叉积的结果还是一个向量，叉积的标准计算方法如下图：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20200928001327577.png" alt="image-20200928001327577" style="zoom:50%;"></p>
<p>结果向量的大小是两个相乘向量所形成的平行四边形的面积，它的方向由右手法则确定——which means 叉积不满足交换律。</p>
<h2 id="09-基变换"><a href="#09-基变换" class="headerlink" title="09 基变换"></a>09 基变换</h2><p>本节的基变换讲的是，如何在两个不同的坐标系（不同的基向量）之间进行坐标的转换，换一种说法就是，如和从两个坐标系的角度来看同一个向量。这里有个前提是，我们把向量看作一组对基向量数乘的数，同时，我们也必须有一个可供这两个坐标系参考的标准坐标系（一般都是取笛卡尔正交坐标系）。</p>
<p>假设第一个坐标系的两个基向量分别为$\vec a_1$和$\vec a_2$，第二个坐标系的两个基向量分别为$\vec b_1$和$\vec b_2$，我们以第三方的标准坐标系的视角来看，假设$\vec a_1=[1\ 0]^T， \vec a_2=[0\ 1]^T，\vec b_1=[2\ 1]^T，\vec b_2=[-1\ 1]^T$。</p>
<p>现有一个向量，以我们的第三方视角来看$\vec v=[3\ 2]^T$，那么在第一个坐标系中，坐标仍为$[3\ 2]^T$，而在第二个坐标系中，它的坐标变为了$[\frac{5}{3}\ \frac{1}{3}]^T$。那么，如果已知两个坐标系的基向量和一个向量在其中一个坐标系中的坐标，我们该如何得到该向量在另一个坐标系中的坐标呢？</p>
<p>从第一坐标系的基向量变换到第二个坐标系的基向量的变换矩阵，就是第二个坐标系两个基向量所组成的矩阵$[\vec b_1\ \vec b_2]$。如果我们把我一个坐标系中的一个向量$[x\ y]^T$坐标左乘这个矩阵，那么得到了变换后在第二个坐标系中的向量的坐标。但是！这个坐标的数值还是以第一个坐标系的视角来看的（如下图，下方是数值的转换方向）！</p>
<p>于是，实际上我们得到的是，在第二个坐标系中坐标为$[x\ y]^T$的向量在第一个坐标系的角度来看的坐标值（听起来有点绕……看视频的理解会好一点）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005114531405.png" alt="image-20201005114531405" style="zoom:50%;"></p>
<p>如果想从第一个坐标系的向量坐标值转换为第二个坐标系的值，那么可以进行一个逆过程，如下图：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005115309322.png" alt="image-20201005115309322" style="zoom:50%;"></p>
<p>还是以$\vec v=[3\ 2]^T$作为例子，如果我们想知道$\vec v$在第二个坐标系中的坐标是多少，那么就左乘该基变换矩阵的逆矩阵：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005115710340.png" alt="image-20201005115710340" style="zoom:50%;"></p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005120031333.png" alt="image-20201005120031333" style="zoom:50%;"></p>
<p>以上讲述的是针对<strong>一个向量在两个坐标系中的转换</strong>，我们还可以扩展到<strong>如何在两个坐标系中描述同一种线性变换</strong>。</p>
<p>现在我们知道第二个坐标系中的向量$\vec v_2$，想要知道在第二个坐标系中做逆时针旋转90°的变换，但目前我们只知道第一个坐标系下表示的第二个坐标系的基向量$A$，我们可以通过如下操作来实现：</p>
<p>1.把$\vec v_2$转换为第一个坐标系中的值</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005143158500.png" alt="image-20201005143158500" style="zoom:33%;"></p>
<p>2.在第一个坐标系中进行逆时针旋转90°的变换</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005143259207.png" alt="image-20201005143259207" style="zoom:33%;"></p>
<p>3.再转换回第二个坐标系中的坐标值</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005143321058.png" alt="image-20201005143321058" style="zoom:33%;"></p>
<p>左侧的三个矩阵可以归纳为：$P^{-1}AP$形式，也就是线代数上<strong>相似矩阵</strong>的定义。</p>
<p>中间的$A$就是在第一个坐标系下（你所见到的）一种变换，而$P$则是由第一个坐标系变换到另一个坐标系的<strong>基变换矩阵</strong>（也就是变换后的基向量构成的矩阵）。</p>
<blockquote>
<p> 本节的总结可能不是很清楚，可以参考原视频或者下文：</p>
<p><a href="https://zhuanlan.zhihu.com/p/69069042" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69069042</a></p>
</blockquote>
<h2 id="10-特征向量与特征值"><a href="#10-特征向量与特征值" class="headerlink" title="10 特征向量与特征值"></a>10 特征向量与特征值</h2><p>书上特征值与特征向量的公式如下:</p>
<script type="math/tex; mode=display">
A\vec v=\lambda\vec v</script><p>其中$\vec v$称为$A$的特征向量，$\lambda$称为特征值。</p>
<p>其实学完之前的矩阵与向量的乘法和数乘之后，我们也能从这个式子中推测出来特征值与特征向量的几何意义——特征向量就是一个向量，这个向量满足以下的特性：<strong>经过一个线性变换后，变换向量仍然保持在原向的方向上（换一种说法就是，特征向量经过线性变换后，变换前后的两个向量所张成的空间并没有发生改变的），只是在长度上有所缩放，缩放的倍数就是特征值$\lambda$。</strong></p>
<p>关于特征值和特征向量的求法，思路如下：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003114021759.png" alt="image-20201003114021759" style="zoom:50%;"></p>
<p>然后把相应的$\lambda$带入原方程，用行/列变换化简$(A-\lambda I)$，然后给$\vec v$中的一个变量手动赋值（一般取1），就可以解出其他的变量（因为特征向量本来就不是一定的数值，可以有数乘关系）。</p>
<p>如果一个变换矩阵恰好是对角矩阵，也就是仅仅在对角线上有值，其他都为0，那么这就是说，这个变换的基向量刚好都是特征向量，这个变换只对基向量的长度进行缩放，于是连续对某一向量进行多个该矩阵的变换计算就很容易了（如下图）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003120729541.png" alt="image-20201003120729541" style="zoom:50%;"></p>
<p>可以化简为下式：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003120747334.png" alt="image-20201003120747334" style="zoom:50%;"></p>
<p>如果是遇到一个非对角矩阵的连续乘法，直接计算会非常痛苦（如下图）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003122104635.png" alt="image-20201003122104635" style="zoom:50%;"></p>
<p>但是学过09的基变换之后，我们可以把这个变换看作在另一个以该变换的两个特征向量为基向量的视角下进行100次变换，然后再把结果从那个视角下变换回来，就可以很容易计算出来结果（如下图，换了一个矩阵作为例子）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003123846057.png" alt="image-20201003123846057" style="zoom:50%;"></p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003124033910.png" alt="image-20201003124033910" style="zoom:50%;"></p>
<p>上图的过程也被称为<strong>矩阵的对角化</strong>。</p>
<h2 id="11-抽象向量空间"><a href="#11-抽象向量空间" class="headerlink" title="11 抽象向量空间"></a>11 抽象向量空间</h2><p>回到第01节中的一个问题，在数学家眼里，什么是向量呢？</p>
<p>事实上，向量这个概念可以是任何一组事物的几何，比如，空间中的一组箭头、计算机中的一组数、一组函数等。</p>
<p>其中，一个多项式函数也可以看作一个向量，所有的多项式函数就构成了一个向量空间。But，为什么？</p>
<p>如果一个事物满足向量的相加与数乘的性质，那么就可以被看作向量。多项式函数正好满足：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003175715263.png" alt="image-20201003175715263" style="zoom:33%;"></p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003175726265.png" alt="image-20201003175726265" style="zoom:33%;"></p>
<p>任何一个变换，满足线性的性质，就能被看作线性变换，线性性质包括可加性和齐次性（如下图）。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003172625939.png" alt="image-20201003172625939" style="zoom:50%;"></p>
<p>以函数为向量（空间），那么变换就是把一个函数变成另一个函数。</p>
<p>例如，微积分里的微分和积分都是线性变换，因此，他们都可以用矩阵的形式表示出来。我们也把这些变换叫做<strong>线性算子</strong>。</p>
<p><strong>如何一个事物，它想能应用我们之前在线性代数中所推出的任何结论，它满足以下八条公理：</strong></p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201003180452468.png" alt="image-20201003180452468" style="zoom:50%;"></p>
<h2 id="12-克莱姆法则"><a href="#12-克莱姆法则" class="headerlink" title="12 克莱姆法则"></a>12 克莱姆法则</h2><p>首先我们看看什么是克莱姆法则，给出以下一个线性方程组：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201004171257529.png" alt="image-20201004171257529" style="zoom:50%;"></p>
<p>克莱姆法则的求解方法如下，即把变换后的向量依次替换到变换矩阵中的对应位置后，计算其行列式，并除以原矩阵的行列式：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201004171321619.png" alt="image-20201004171321619" style="zoom:50%;"></p>
<p>首先我们以一个二维的向量$\vec v=[x,\ y]^T$来作为例子：</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201004170814887.png" alt="image-20201004170814887" style="zoom:50%;"><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201004170832199.png" alt="image-20201004170832199"></p>
<p>它与一个基向量所构成的平行四边形的面积（有符号的）就是它的一个坐标值，上图就是与$\vec i$构成的情况（与$\vec j$的情况可类比）。</p>
<p>经过一个线性变换矩阵$A$之后，上图区域的面积就变成了$det(A)\cdot y$，由于是线性方程组，变换后的向量我们已经知道了（以下图为例就是$[4\ 2]^T$），于是$[4\ 2]^T$与$\vec i$变换后的新的基向量$[2\ 0]^T$所构成的平行四边形就是$det(A)\cdot y$，于是y就等于新的面积（变换后的向量与变换后的一个基向量所构成矩阵的行列式）除以A的行列式，x的求法可以类比。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005105336931.png" alt="image-20201005105336931" style="zoom:50%;"></p>
<p>在三维空间中，面积就被类比成了体积（如下图），其他的也很容易推导出来。</p>
<p><img src="/2020/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20201005105923798.png" alt="image-20201005105923798" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache映射机制与逻辑实现</title>
    <url>/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Cache是现代CPU中不可缺少的一部分，大大提高了CPU访问数据的速度。</p>
<p>Cache与主存（RAM）的映射关系分为三类：</p>
<ul>
<li>直接相联</li>
<li>全相联</li>
<li>组相联</li>
</ul>
<a id="more"></a>
<h2 id="直接相联映射"><a href="#直接相联映射" class="headerlink" title="直接相联映射"></a>直接相联映射</h2><p>直接相联就是主存中的一块（行）只能映射到Cache中固定的某一块（行）。</p>
<blockquote>
<p>一块（Block）中包含多个字。</p>
</blockquote>
<p>同时，主存会根据Cache的块的数量来分区，假设Cache有n块，那么主存中每n块就构成一个区。于是主存地址可以分为3个部分：<strong>区地址、行地址、字地址</strong>，如下图：</p>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822113513832.png" alt="image-20200822113513832" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<p>Cache的存储器中，存储一行数据的同时，还会存储区地址以及一些标志位（有效位、一致性Dirty位等），以供在查找数据的时候的判断。</p>
<p>查找的流程如下：</p>
<ol>
<li>根据行地址查找Cache中对应的行</li>
<li>根据区地址（标记位TAG）以及一些标志位（有效位 ）来判断是否与主存中所要查找的区对应</li>
<li>如果TAG一致，则输出该行的数据内容，同时根据字地址来选择最终字的输出</li>
<li>如果TAG不一致，则从主存中载入到相应地址的内容到Cache中，再由Cache传输给CPU</li>
</ol>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822111450390.png" alt="image-20200822111450390" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<blockquote>
<p>这种方法的命中率较低，因为主存中的块只能对应一个Cache块。一个块可能刚进入Cache，就被另一个块给覆盖了。</p>
<p>不过其优点是硬件逻辑简单，成本较低。</p>
</blockquote>
<h2 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h2><p>全相联就是主存中的任意一块（行）可以放在Cache中的任意一块（行）中，没有分区的概念。于是贮存地址就只分为两部分：<strong>主存块地址（标记部分）、字地址</strong>。</p>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822185746130.png" alt="image-20200822185746130" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<p>由于主存中一个块对应的Cache块地址不确定，所以需要其他的结构来辅助确定，即查找表。查找表的行数与Cache的行数相同，每一行存放着一个主存块地址，一个对应的Cache块地址，以及一些标志位。值得注意的是，查找表（CAM）与Cache是分开存放的，而直接相联中的区地址、标记位等与Cache数据则是一起存放的。</p>
<p>查找流程如下：</p>
<ol>
<li>根据主存块地址在CAM中并行查找Cache中是否存在该块地址</li>
<li>若存在，则根据该行对应的Cache块地址直接访问Cache中的相应行，然后根据字地址选择输出的字</li>
<li>若不存在，则从RAM中载入相应地址的块到一个空的Cache行中，然后输出</li>
</ol>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822203942775.png" alt="image-20200822203942775" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<blockquote>
<p>这种方法的命中率比直接相联要高不少，不过其缺点就是硬件开销较大。</p>
</blockquote>
<h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p>组相联映射结合了直接相联和全相联的特点，首先将Cache分为n组，一组中有k行。主存中也是按照每n行进行分割（类比直接相联的分区），每一行只能进入到相应的Cache组中，但是可以是组中的任意一行（类比全相联）。</p>
<blockquote>
<p>每一组中的行数即路数，有k行则被称为k路组相联</p>
</blockquote>
<p>于是主存的地址就被分为3个部分：<strong>标记字段（区地址）、组地址、字地址。</strong></p>
<p>Cache中一行的组成与直接相联映射类似。</p>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822210623668.png" alt="image-20200822210623668" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<p>查找的流程如下：</p>
<ol>
<li>首先根据组地址来确定所要查找的组，相应的组信号（S0-3）</li>
<li>根据标记字段TAG、有效位确定所要查找的行是否存在于该组中，并输出相应信号（K0、K1…）</li>
<li>根据（K0、K1…）以及组信号（S0-3）确定Cache中具体的某一行</li>
<li>根据字地址选择最终输出的字</li>
<li>若在第2步中，不存在所要查找的行，则从主存中载入，然后再进行步骤3</li>
</ol>
<p><img src="/2020/08/22/Cache%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/image-20200822211010019.png" alt="image-20200822211010019" style="zoom:33%;"></p>
<center>来源于华中科技大学课件</center>

<blockquote>
<p>由组相联的映射机制可知，它结合了直接相联和全相联的特点，是一个比较折中的方案，命中率相比直接相联要高，但是硬件成本也要高一些，相比全相联，其硬件成本较低，但是命中率也要低一些。</p>
</blockquote>
<p>由此，我们可以得到一个真理——这个世界上没有什么事物是各个方面都理想的，想要在某方面有所提升，就要付出相应的代价！</p>
<p>同理，想成为大佬就要付出努力！</p>
<blockquote>
<p>参考资料：</p>
<p>《计算机硬件系统设计》.华中科技大学计算机学院</p>
<p>链接：<a href="https://www.icourse163.org/course/HUST-1205809816" target="_blank" rel="noopener">https://www.icourse163.org/course/HUST-1205809816</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成与体系结构</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>《自己动手写CPU》读后小结</title>
    <url>/2020/02/19/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8B%E8%AF%BB%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>本书的前11章是教学版的OpenMIPS CPU设计过程，后面的章节是实践版的设计和实物的实验。对于本书的名字《自己动手写CPU》来说，我认为前12章就已经完成了任务。后面部分的实验需要DE2开发板的支持，所以暂时做不了。</p>
<p>当初看这本书的目的是进一步了解计算机组成与体系结构，因为上学期上了一门《计算机组成与体系结构》的课，感觉学得很模糊，于是想着干脆通过自己写一个CPU来增强一下对计算机的理解。网上推荐的书有《自己动手写CPU》和《CPU自制入门》，比较了一下感觉前者更适合我，便开始着手看了。</p>
<p>看完这本书的首要感想是，原来<strong>CPU并没有那么神秘！</strong></p>
<a id="more"></a>
<p>在这里我想讲一下两方面的收获：</p>
<ol>
<li>CPU的结构与设计</li>
<li>计算机组成与体系结构</li>
</ol>
<p><strong>首先说一说我之前对CPU的一些好奇和疑惑：</strong></p>
<p>以前的我只知道CPU是按照时钟的频率的工作的，但是不知道为什么要由时钟来控制，以及如何控制，同时也会想，既然是按照时钟来工作，那为什么不“无限制”提高频率以加快CPU的处理速度呢？</p>
<p>看完本书后，我知道了这些问题的答案。</p>
<p>首先，为什么要有时钟？是为了保证CPU内部的正常秩序，“到了什么时间就做什么事”，没有一个良好的秩序，一个团队的效率是不可能高的，甚至乱作一团，导致不能工作。</p>
<p>那么，时钟是如何控制（组织）CPU内部的工作的呢？时钟会产生一个周期信号，我们可以规定在信号的每一个上升沿or下降沿开始执行一个操作，CPU中的不同模块能同时进行操作，但CPU中的一个模块在同一个时刻只能做一件事，这样就能保证各个模块之间不冲突，各个功能正常执行。</p>
<p>那么是不是一直提高时钟的频率，就能一直无限制地提高CPU的执行速度呢？显然是不可能的，如果真是这样的话那么为啥CPU厂商自己不大幅提高时钟频率呢。第一个事实是由于CPU电路中的信号是有延迟的，一个操作的结果不可能立刻反映在输出电路上，如果无限制提高时钟频率，那么会导致“运算”跟不上时钟，从而导致CPU内部的秩序又消失了，变得混乱。第二就是由于电路中电子的运动是要消耗能量的，执行地越快，单位时间内消耗的能量就越多，发热量就越大，散热就会跟不上，从而导致内部电路“失效”，电脑蓝屏、死机or自动关机。</p>
<p>By the way，时钟频率并不是唯一决定处理器性能的东西，这也就是为什么AMD的主频一般没有同级别的Intel家的主频高，但是性能却不相上下甚至超过Intel的原因（AMD YES！）。</p>
<h3 id="CPU的结构及设计"><a href="#CPU的结构及设计" class="headerlink" title="CPU的结构及设计"></a>CPU的结构及设计</h3><p>CPU的本质就是一个只会“解释指令”，并且死板地执行指令的莫得感情的机器，有一个比喻说得好：硬件是计算机的躯体，OS才是灵魂。它的主要结构（或者说最基本的结构）包括译码器、ALU以及各种寄存器。</p>
<p>我们会给具体指令集中的指令规定固定的格式，以便让译码器理解代码，其实原理很简单，CPU译码的过程相当于就是查字典，在规定的有限的指令集内找到与输入的机器码相匹配的情况，并执行相应的操作。</p>
<p>ALU（Arithmetic Logic Unit）的中文名是算术逻辑单元，顾名思义，主要是执行算术/逻辑操作的单元，计算机的各种“计算”都是在这里完成的。</p>
<p>寄存器是用来保存运算的输入数据、中间结果and结果的存储单元，其位于CPU内部，访问速度最快（在计算机体系中）。但也有一些特殊的寄存器并不用于计算，比如PC（Program Counter）程序计数器，它的值是下一个将要取到的指令的地址。</p>
<p>前面说过CPU中的各个模块按照时钟来运行的，为了进一步提高效率，人们使用了流水线结构，类似于工厂众多的流水线，将一条指令（商品）的执行过程分为多个步骤（或阶段），每一个步骤由一个专门的模块来负责，这个模块的任务就是接收从上一个阶段传来数据，经过它自己的处理后，再传递给下一个模块。</p>
<p>本书的Open MIPS CPU采用的是<strong>五级流水线</strong>，将一条指令分为五个步骤：取指、译码、执行、访存（RAM）、回写（寄存器）。具体实现流水线的方式就是通过组合电路和时序电路的组合级联而，由组合电路完成具体的操作，由时序电路完成按照时钟传递数据的任务，以保证指令的有序执行。</p>
<p>同时，由于采用了流水线结构，也会相应地带来<strong>相邻指令间</strong>的相关问题（具体见笔记第五、八、九章），简单来说就是：假如一条指令的结果是在最后一个流水线阶段才写入的，此时流水线的前几个阶段已经在处理后面几条指令了，如果这几条指令需要的结果正好是该指令将要写入的（但是还没写入），那么就会产生相关问题。对应的解决方案在笔记中也介绍过，简单来说有：数据前推、暂停流水线、编译器调度（不属于CPU的能力范围）。其中数据前推就是在流水线中新增一些从流水线后面几个阶段到前面几个阶段的数据反馈回路，然流水线的前几个阶段提前获取前面指令的结果。暂停流水线是通过新增ctrl模块实现的。</p>
<p>在运行过程中，CPU难免会遇到一些出错的情况（例如：溢出，除数是0等），这就需要一个异常处理机制了。为了实现精确异常，采用的策略是在前面几个流水线阶段检测异常但不立即操作，在一个固定的流水线阶段统一请求异常处理。</p>
<p>至于协处理器，就是辅助CPU的处理器，其中包含一些特殊寄存器，辅助CPU的判断/异常处理，有的协处理器也能帮助CPU完成一部分计算工作（例如：浮点运算协处理器）。</p>
<h3 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h3><p>什么是计算机体系结构？那本黑皮书《计算机组成与体系结构（性能设计）》中定义为</p>
<blockquote>
<p>计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性</p>
</blockquote>
<p>对于不同层次的程序员来说，他们看到的计算机的属性也不相同。例如，对现在的许多高级语言程序员来说，他们看到的计算机的属性大多数是操作系统（OS）提供的，而对于OS程序员来说，他们看到的体系结构就是ISA（或许还有其他我目前不知道的…）提供的。</p>
<p>至于计算机组成，就是由五个经典的部分组成：输入、输出、存储器、数据通路（运算器）、控制器。后面两个部分组成CPU，通过本书的前11章，我们也实现了这两个部分。</p>
<p>首先，任何一个ISA都会提供给底层程序员几个类别的指令，本书实现的Open MIPS就包括了：逻辑指令、位移指令、（数据）移动指令（寄存器之间相互移动）、算术指令、转移指令、加载存储指令（寄存器与ram和rom之间移动）、协处理器访问指令、异常相关指令。ISA所提供的指令类别需要保证通过不同指令的组合就能完成任何程序的任何逻辑，现在同一个类（RISC或CISC）中的不同ISA的指令类别应该大同小异了。</p>
<p>具体的指令设计可是一个大学问，这需要考虑到指令有哪些格式，什么样功能的指令是必要的，什么是冗余的，如何设计执行过程的方法才能提升指令的执行效率。当然，这些都是那些专门设计指令集的大佬们干的事，本书实现的Open MIPS仅仅是把现有的开源指令集拿来实现（并且还是简化版的）。</p>
<p>不同的指令执行所需要的时间也不一定一样，在Open MIPS中，大部分指令执行阶段都只需要一个时钟周期，少部分需要两到三个，最花时间的是除法指令，它需要至少32个时钟周期，这是由除法本身的算法（试商法）决定的。</p>
<p>实现同一个功能可以由多种不同的指令组合完成，如何提高程序的执行效率，也就可以通过寻找所需最短时间的指令组合来实现，这个过程是由编译器（无论是高级语言编译器还是汇编器）实现的。实现这个我想并不容易，否则编译原理也就不会是CS系学生的噩梦了（顺便膜拜一波写编译器的大佬们）。<strong>同时这也给我们编写高级语言程序的时候一些启示</strong>：了解一些高级语言语句的汇编实现是有用的，因为这可以让我们判断哪一种实现方法更有效率（所需的时钟周期更少）/汇编语句更少（节省内存空间），这是让我们编写出更好的程序的一种技巧（个人观点）。<strong>举个栗子</strong>，调用函数操作的汇编语言实现一般都是跳转指令配合标签，同时会用到栈（将调用前的寄存器值压入栈），如果使用递归的话，就会多次调用函数，多次将寄存器的值压入栈，如果递归深度太深，那么栈就可能溢出，导致程序错误，同时相比非递归函数，这个压入栈的操作会被执行很多次，就浪费了时间，同时也浪费了空间。这也是为什么一般不轻易采用递归结构的原因，当然，对于现代的CPU/PC机来说，我们平时写的那些递归的深度及操作复杂度都不是太大的问题（因为执行速度够快而浪费的时间可以接受，因内存够大而导致栈空间的浪费可以接受，不过这个栈的大小是有限度的，因而也可能溢出，但也可以手动设置栈的大小）。</p>
<blockquote>
<p>在《计算机组成与体系结构（性能设计）》中，还讲到过指令发射策略，本质上是一种改变指令执行顺序来提高执行效率的过程（前提是程序逻辑不变），不过这里我看地有些似懂非懂……也就不详细说了。</p>
</blockquote>
<p>为了方便CPU与外部设备的交互，我们采用了总线的结构，具体原因在十二章的笔记中有说过，进一步总结就是，为了<strong>减少</strong>不同功能模块之间的<strong>耦合</strong>，因此通过一个中间模块（在这里就是总线）来使需要连接的模块的接口标准化，使模块之间的互联逻辑变得清晰，易于维护修改。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>总的来说，这本书所实现的CPU很简单，内容也不是很多（就是代码多了点），与当今时代个人PC机的CPU差别挺大的，有许多高级设计并没有使用到（这也是为了降低难度），例如：超标量流水线、指令发射、指令预测等等。对这些感兴趣的话可以看看上面提到的那本黑皮书，不过说实话。。。中文翻译得确实不是很流畅，有些地方不慢慢地多读多想不易理解（当然，这也与知识本身的难度有关）。</p>
<p>话说回来，看这本书的收获也挺多，可以算是入了CPU和计算机硬件的门，我想，如果是先看完本书之后再去看那本黑皮书或者《计算机组成与设计（硬件/软件接口）》（该书正好就是用MIPS指令集来做例子的）也是极好的，能帮助理解其中的许多概念（流水线、延迟槽、相关性问题、异常处理等等），也不会像我当初上课时那样摸不着头脑了。</p>
<p>PS：建议看本书之前最好有数电基础。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机组成与体系结构</category>
        <category>《自己动手写CPU》</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>计算机组成</tag>
        <tag>体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, look here!</title>
    <url>/2020/02/18/Hello-look-here/</url>
    <content><![CDATA[<p><strong>这儿有一些我对本博客的说明：</strong></p>
<p>我曾经在2018年用学生服务器搭建过一个博客，弄过域名，备过案，感觉有些麻烦。目前到期了，也懒得继续弄了，干脆借着Github的平台来搭建一个。</p>
<p>我在Github上有一个记录学习笔记的仓库（<a href="https://github.com/Floral/Study" target="_blank" rel="noopener">https://github.com/Floral/Study</a> ），里面主要是我看的一些书籍的笔记，内容主要<a id="more"></a>来源于书本和我的一些总结，尽量写的清晰，代码主要是手敲，部分来源于所看的课程自带的（例如吴恩达的ML课程），为了完整性就一起上传了，希望能对大家有所帮助，也欢迎大家与我讨论书中的内容。</p>
<p>由于我在那个仓库记录的笔记主要是以一整本书为单位的，因此一个md文件会“又臭又长”，我会将它们放在本博客上，同时也会<strong>考虑</strong>将内容分段上传（单独当作记录一个or几个知识点的blog），不过暂时……</p>
<p>今后，我会将平时遇到的一些问题、思考、学到的一些知识点、乃至经历，写下来，记录于本博客。作为一名理工科学生，不擅长写作的我会尽力表达地易于理解。还有一点要说的是，由于我个人的能力有限，笔记中的有些话并不一定完全正确，都是在我个人的理解下写下来的，如果有什么理解错误的地方，欢迎指正、交流、讨论！</p>
<p>以下是目前仓库中各笔记相关的学习书籍、资料：</p>
<ol>
<li><p>自己动手写CPU</p>
<ul>
<li>《自己动手写CPU》    雷思磊</li>
</ul>
</li>
<li>汇编语言<ul>
<li>《汇编语言（第三版）》 王爽</li>
</ul>
</li>
<li><p>C++</p>
<ul>
<li>《Essential C++》</li>
<li>《C++ Primer》（第五版）</li>
</ul>
</li>
<li><p>数据结构与算法</p>
<ul>
<li>《算法竞赛入门经典（第二版）》</li>
<li>《数据结构（C++语言版）》（第三版） 邓俊辉</li>
<li>《数据结构与算法分析——C++语言描述》（第四版） [美] Mark Allen Weiss</li>
</ul>
</li>
<li><p>MachineLearning</p>
<ul>
<li>《Machine Learning》.coursera mooc.吴恩达</li>
<li>人工智能实践：TensorFlow笔记.北京大学MOOC</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>浅谈继承中函数有无virtual的影响</title>
    <url>/2020/01/28/%E6%B5%85%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%87%BD%E6%95%B0%E6%9C%89%E6%97%A0virtual%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>本文讨论了一下C++的继承关系中函数加或不加virtual的影响，总结了一下本人对动态绑定、静态绑定的理解。</p>
<a id="more"></a>
<p>首先直接上一段实验代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* virtual */</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm A!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm B!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    A* p = &amp;b;</span><br><span class="line">    p-&gt;func();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// a.func();</span></span><br><span class="line">    <span class="comment">// b.func();</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的输出结果是：I’m A!。如果p的声明类型是B*，那么输出结果是：I’m B!。这里基类A的func方法并没有加virtual关键字。如果我们加上virtual，那么结果就会变成，无论p的声明是A*还是B*，输出结果都是：I’m B!。</p>
<p>但是如果我们在这里直接通过对象本身a或b调用他们的func方法，那么结果就是调用它们各自类型中定义的func，也就是a.func()输出“I’m A!”。b.func()输出“I’m B!”。</p>
<p>于是我们可以总结一下，virtual只是对于<strong>通过指针</strong>（<strong>引用</strong>也行，大家可以自行实验）<strong>来调用父类子类的方法</strong>有影响。在父类的func前加上virtual的情况下，通过指针（或引用）调用该方法，实际调用的是该指针所指向的实际的类中定义的方法。这也就是<strong>动态绑定</strong>的意思，也就是在运行的过程中动态确定指针（或引用）所指向的实际对象是什么（是父类还是子类）并调用实际对象的方法。相对的，<strong>静态绑定</strong>就是仅仅根据声明的指针或引用的类型来决定调用的方法，即静态绑定到了<strong>声明对象的类型</strong>上。</p>
<p>因此，无论父类的方法加不加virtual，<strong>通过对象本身调用</strong>重载过的方法都是对象本身定义的方法。</p>
<p>至于为什么动态绑定和静态绑定只是针对使用指针和引用的情况，个人觉得这是因为指针/引用在实现多态、模板的时候具有很大的用处。</p>
<p>这里有一条建议，来自《Effective C++ 》：</p>
<blockquote>
<p>绝对不要重新定义继承而来的非虚(non-virtual)函数</p>
</blockquote>
<p>也就是说，本次实验的原始代码中B类重载A的非虚函数func的做法是不好的，这里仅仅是为了实验。具体原因嘛，由于篇幅限制，就不展开了，请各位自行搜索。</p>
<p><strong>PS:</strong> 这里所说的静态绑定、动态绑定的含义仅仅是针对程序运行的结果来说的（主要是便于理解其实际影响），这两个概念的背后其实还有一些更深入的知识点，例如：静态类型、动态类型、编译期、运行期。想要了解的话也请各位自行搜索。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>动态/静态绑定</tag>
        <tag>virtual关键字</tag>
      </tags>
  </entry>
</search>
